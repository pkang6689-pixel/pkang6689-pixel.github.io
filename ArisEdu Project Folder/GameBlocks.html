<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Puzzle - Logic Challenge</title>    <script src="firebase-utils.js"></script>
    <style>
        #game-session-timer {
            font-size: 2.5rem !important;
            font-weight: 700 !important;
        }
    </style>    <script>
        let timerIntervalId;
        let drainIntervalId;
        
        (async function() {
            await initializeFirebase();
            
            if (sessionStorage.getItem('validGameAccess') !== 'true') {
                alert('You must access this game from the Arcade page.');
                window.location.href = 'arcade.html';
                return;
            }
            
            function getUser() {
                return JSON.parse(localStorage.getItem('user') || '{}');
            }
            
            function saveUser(user) {
                localStorage.setItem('user', JSON.stringify(user));
            }

            function showOutOfTokensPopup() {
                clearInterval(timerIntervalId);
                clearInterval(drainIntervalId);
                
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:99999;display:flex;align-items:center;justify-content:center;';
                
                const modal = document.createElement('div');
                modal.style.cssText = 'background:white;border-radius:1rem;padding:2rem;max-width:400px;text-align:center;box-shadow:0 20px 25px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="font-size:3rem;margin-bottom:1rem;">💸</div>
                    <h2 style="font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#1e293b;">Out of Tokens!</h2>
                    <p style="margin-bottom:1.5rem;color:#64748b;">Your token balance hit zero.</p>
                    <p style="margin-bottom:1.5rem;color:#94a3b8;font-size:0.85rem;">Earn more tokens by completing lessons and quizzes!</p>
                    <button id="back-to-arcade" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#f59e0b;color:#000;cursor:pointer;font-weight:700;font-size:1rem;">Back to Arcade</button>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                modal.querySelector('#back-to-arcade').onclick = () => {
                    sessionStorage.removeItem('validGameAccess');
                    window.location.href = 'arcade.html';
                };
            }
            
            window.initializeTokenDrain = function() {
                const sidebar = document.getElementById('game-sidebar');
                if (!sidebar) return;
                
                let timerDisplay = document.getElementById('game-session-timer');
                if (!timerDisplay) {
                    timerDisplay = document.createElement('div');
                    timerDisplay.id = 'game-session-timer';
                    sidebar.appendChild(timerDisplay);
                }

                function updateTimerDisplay() {
                    const user = getUser();
                    const remaining = Math.max(0, user.points || 0);
                    timerDisplay.textContent = remaining + '💎';
                    timerDisplay.className = remaining <= 20 ? 'warning' : '';
                    
                    if (remaining <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                function drainTokens() {
                    const user = getUser();
                    const pts = user.points || 0;
                    if (pts > 0) {
                        user.points = pts - 1;
                        saveUser(user);
                        updateTimerDisplay();
                    } else if (pts <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                if (timerIntervalId) clearInterval(timerIntervalId);
                if (drainIntervalId) clearInterval(drainIntervalId);
                
                updateTimerDisplay();
                drainIntervalId = setInterval(drainTokens, 1000);
                
                // Pause drain when page is hidden
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        clearInterval(drainIntervalId);
                    } else {
                        drainIntervalId = setInterval(drainTokens, 1000);
                    }
                });
            };

            document.addEventListener('DOMContentLoaded', window.initializeTokenDrain);
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        body { font-family: 'Orbitron', monospace; padding-top: 50px; }
        #game-sidebar {
            background: rgba(55, 65, 81, 0.98);
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 400px;
            min-height: 800px;
            border: 2px solid rgba(107, 114, 128, 0.9);
            box-shadow: 0 20px 45px rgba(0,0,0,0.6);
        }
        #game-session-timer {
            background: rgba(34, 197, 94, 0.95);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            font-size: 2rem;
            font-family: monospace;
            width: 100%;
            text-align: center;
            margin-top: 0.5rem;
            letter-spacing: 2px;
        }
        #game-session-timer.warning {
            background: rgba(239, 68, 68, 0.95);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .grid-cell { transition: background-color 0.2s; }
        .block-shape { 
            touch-action: none; 
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .block-shape * {
            pointer-events: none;
        }
        .filled { animation: neonPulse 1.5s infinite alternate; }
        @keyframes neonPulse {
            from { box-shadow: 0 0 5px currentColor; }
            to { box-shadow: 0 0 15px currentColor; }
        }
        .pause-btn { position: absolute; bottom: 0.75rem; left: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .pause-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        :fullscreen { background: #111827; }
        #game-wrapper {
            margin-left:150px;
            width: min(720px, calc(100vw - 360px));
            max-width: 100%;
        }
    </style>
    <script src="theme_manager.js"></script>
</head>
<body class="dark-mode bg-gray-900 min-h-screen text-white">
<script src="scripts/taskbar.js"></script>

    <div class="flex flex-row items-start justify-start p-4 gap-10 overflow-x-auto overflow-y-visible">

    <!-- Game UI -->
    <div id="game-wrapper" class="relative flex-shrink-0 max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
        <button class="pause-btn" onclick="togglePause()" title="Pause"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
        <!-- Header -->
        <div class="flex justify-between items-end mb-6">
            <div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-green-400 to-emerald-600 bg-clip-text text-transparent">BLOCK PUZZLE</h1>
                <p class="text-xs text-gray-400">Clear lines to score!</p>
            </div>
            <div class="text-right">
                <div class="text-xs text-gray-400 font-sans" data-i18n="SCORE">SCORE</div>
                <div id="score" class="text-3xl font-bold text-white">0</div>
            </div>
        </div>

        <!-- Grid Board -->
        <div id="board" class="grid grid-cols-8 gap-1 bg-gray-900 p-2 rounded-lg border-2 border-gray-700 mx-auto" style="width: 340px; height: 340px;">
            <!-- Cells generated by JS -->
        </div>

        <!-- Draggable Blocks Container -->
        <div id="hand" class="mt-8 flex justify-center gap-4 h-24 items-center min-h-[6rem]">
            <!-- Block Options -->
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-green-400 font-bold mb-2">BLOCK PUZZLE</h2>
            <p class="text-gray-300 mb-4 font-sans">Clear lines and columns to score!</p>
            <p class="text-sm text-gray-400 mb-6 font-sans">Click/Tap and drag blocks to the board. Match rows/columns!</p>
            <button onclick="startGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                <span data-i18n="START">START</span>
            </button>
        </div>

        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-red-500 font-bold mb-2" data-i18n="GAME OVER">GAME OVER</h2>
            <p class="text-gray-300 mb-2 font-sans">No more moves possible!</p>
            <p class="text-xs text-gray-400 mb-6 font-sans">Click & drag blocks onto board<br>P / Esc to pause</p>
            <div class="text-4xl font-bold text-white mb-8" id="final-score">0</div>
            <button onclick="resetGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                <span data-i18n="TRY AGAIN">TRY AGAIN</span>
            </button>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-30 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-4xl text-white font-bold mb-2">PAUSED</h2>
            <p class="text-xs text-gray-400 mb-6 font-sans">Click & drag blocks onto board</p>
            <p class="text-gray-400 mb-8 font-sans">Game is paused</p>
            <button onclick="togglePause()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                <span data-i18n="RESUME">RESUME</span>
            </button>
        </div>

    <div id="game-sidebar">
        <div style="width: 100%; text-align: center; color: #9ca3af; margin-bottom: 1rem; font-size: 0.875rem; font-weight: 600;">
            SESSION
        </div>
    </div>

    </div>

    <script>
        let gamePaused = false;
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pause-screen').classList.toggle('hidden', !gamePaused);
        }
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { togglePause(); e.preventDefault(); }
        });

        // Auto-pause game (and stop timer updates) when tab loses visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (!gamePaused && typeof togglePause === 'function') {
                    togglePause();
                }
                if (typeof timerIntervalId !== 'undefined' && timerIntervalId) {
                    clearInterval(timerIntervalId);
                    timerIntervalId = null;
                }
            } else {
                if ((typeof timerIntervalId === 'undefined' || !timerIntervalId) && typeof window.initializeTimer === 'function') {
                    window.initializeTimer();
                }
            }
        });

        const BOARD_SIZE = 8;
        let grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        let score = 0;
        const colors = ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
        
        const SHAPES = [
            [[1]],
            [[1, 1]],
            [[1, 1, 1]],
            [[1, 1, 1, 1]],
            [[1],[1]],
            [[1],[1],[1]],
            [[1],[1],[1],[1]],
            [[1, 1], [1, 1]],
            [[1, 0], [1, 1]],
            [[0, 1], [1, 1]],
            [[1, 1, 1], [0, 1, 0]],
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1, 1], [1, 1, 0]],
            [[1, 1, 1], [1, 0, 0]],
            [[1, 1, 1], [0, 0, 1]],
        ];

        const boardEl = document.getElementById('board');
        const handEl = document.getElementById('hand');
        const scoreEl = document.getElementById('score');

        // ---- Hand piece data store ----
        let handPieces = []; // [{el, shape, color}, ...]

        // ---- Drag state ----
        let dragging = null;  // {el, shape, color, ghost, offsetX, offsetY, originRect}
        let ghostCells = [];  // cells currently highlighted as preview

        // ---- Board helpers ----
        function initBoard() {
            boardEl.innerHTML = '';
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-full h-full bg-gray-800 rounded-sm';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    boardEl.appendChild(cell);
                }
            }
        }

        function getCell(x, y) {
            return boardEl.children[y * BOARD_SIZE + x];
        }

        function getBoardCellSize() {
            const rect = boardEl.getBoundingClientRect();
            // board has padding 8px (p-2) and gap 4px (gap-1)
            return (rect.width - 16) / BOARD_SIZE; // approximate cell size including gap
        }

        // ---- Spawning ----
        function spawnBlocks() {
            handEl.innerHTML = '';
            handPieces = [];
            for (let i = 0; i < 3; i++) {
                const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const color = colors[Math.floor(Math.random() * colors.length)];
                createDraggableBlock(shape, color);
            }
        }

        function createDraggableBlock(shapeMatrix, color) {
            const container = document.createElement('div');
            container.className = 'block-shape relative';
            container.style.touchAction = 'none';

            const size = 15;
            const w = shapeMatrix[0].length * size;
            const h = shapeMatrix.length * size;

            container.style.width = `${w}px`;
            container.style.height = `${h}px`;

            shapeMatrix.forEach((row, r) => {
                row.forEach((active, c) => {
                    if (active) {
                        const block = document.createElement('div');
                        block.style.cssText = `position:absolute;left:${c*size}px;top:${r*size}px;width:${size-1}px;height:${size-1}px;background:${color};border-radius:2px;pointer-events:none;`;
                        container.appendChild(block);
                    }
                });
            });

            const piece = { el: container, shape: shapeMatrix, color };
            handPieces.push(piece);

            // ---- Pointer-based drag ----
            container.addEventListener('pointerdown', (e) => {
                if (gamePaused) return;
                e.preventDefault();
                startDrag(piece, e);
            });

            handEl.appendChild(container);
        }

        // ---- Drag implementation (pointer events) ----
        function startDrag(piece, e) {
            const el = piece.el;
            const rect = el.getBoundingClientRect();

            // Create a floating ghost copy
            const ghost = el.cloneNode(true);
            ghost.style.position = 'fixed';
            ghost.style.pointerEvents = 'none';
            ghost.style.zIndex = '1000';
            ghost.style.opacity = '0.85';
            ghost.style.transform = 'scale(1.15)';
            ghost.style.transition = 'none';
            document.body.appendChild(ghost);

            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;

            ghost.style.left = (e.clientX - offsetX) + 'px';
            ghost.style.top = (e.clientY - offsetY) + 'px';

            // Dim original
            el.style.opacity = '0.3';

            dragging = { ...piece, ghost, offsetX, offsetY, originRect: rect };

            el.setPointerCapture(e.pointerId);
        }

        function onPointerMove(e) {
            if (!dragging) return;
            e.preventDefault();

            const { ghost, offsetX, offsetY } = dragging;
            ghost.style.left = (e.clientX - offsetX) + 'px';
            ghost.style.top = (e.clientY - offsetY) + 'px';

            // Board preview
            updateGhostPreview(e.clientX, e.clientY);
        }

        function onPointerUp(e) {
            if (!dragging) return;
            e.preventDefault();

            const { shape, color, ghost, el } = dragging;
            const cell = getBoardCell(e.clientX, e.clientY);
            let placed = false;

            if (cell) {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                // Offset: place so the top-left of shape aligns with hovered cell
                if (canPlace(shape, x, y)) {
                    place(shape, x, y, color);
                    placed = true;
                    // Remove piece from hand
                    el.remove();
                    handPieces = handPieces.filter(p => p.el !== el);
                    checkLines();
                    if (handPieces.length === 0) spawnBlocks();
                    checkGameOver();
                }
            }

            // Cleanup
            ghost.remove();
            clearGhostPreview();
            if (!placed) {
                el.style.opacity = '1';
            }
            dragging = null;
        }

        // Attach global listeners
        document.addEventListener('pointermove', onPointerMove, { passive: false });
        document.addEventListener('pointerup', onPointerUp, { passive: false });
        document.addEventListener('pointercancel', onPointerUp, { passive: false });

        // ---- Board cell from screen coords ----
        function getBoardCell(cx, cy) {
            const rect = boardEl.getBoundingClientRect();
            const pad = 8; // p-2 = 8px
            const innerX = cx - rect.left - pad;
            const innerY = cy - rect.top - pad;
            const cellW = (rect.width - pad * 2) / BOARD_SIZE;
            const cellH = (rect.height - pad * 2) / BOARD_SIZE;
            const gx = Math.floor(innerX / cellW);
            const gy = Math.floor(innerY / cellH);
            if (gx < 0 || gx >= BOARD_SIZE || gy < 0 || gy >= BOARD_SIZE) return null;
            return getCell(gx, gy);
        }

        // ---- Ghost preview on board ----
        function updateGhostPreview(cx, cy) {
            clearGhostPreview();
            if (!dragging) return;

            const rect = boardEl.getBoundingClientRect();
            const pad = 8;
            const cellW = (rect.width - pad * 2) / BOARD_SIZE;
            const cellH = (rect.height - pad * 2) / BOARD_SIZE;
            const innerX = cx - rect.left - pad;
            const innerY = cy - rect.top - pad;
            const gx = Math.floor(innerX / cellW);
            const gy = Math.floor(innerY / cellH);

            if (gx < 0 || gx >= BOARD_SIZE || gy < 0 || gy >= BOARD_SIZE) return;

            const { shape, color } = dragging;
            const valid = canPlace(shape, gx, gy);

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (!shape[r][c]) continue;
                    const bx = gx + c, by = gy + r;
                    if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) continue;
                    const cell = getCell(bx, by);
                    cell.dataset.prevBg = cell.style.backgroundColor || '';
                    cell.dataset.prevShadow = cell.style.boxShadow || '';
                    if (valid) {
                        cell.style.backgroundColor = color;
                        cell.style.opacity = '0.45';
                        cell.style.boxShadow = `0 0 8px ${color}`;
                    } else {
                        cell.style.backgroundColor = '#ef4444';
                        cell.style.opacity = '0.3';
                        cell.style.boxShadow = '0 0 8px #ef4444';
                    }
                    ghostCells.push(cell);
                }
            }
        }

        function clearGhostPreview() {
            ghostCells.forEach(cell => {
                cell.style.backgroundColor = cell.dataset.prevBg || '';
                cell.style.boxShadow = cell.dataset.prevShadow || '';
                cell.style.opacity = '1';
                delete cell.dataset.prevBg;
                delete cell.dataset.prevShadow;
            });
            ghostCells = [];
        }

        // ---- Placement logic ----
        function canPlace(shape, x, y) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const bx = x + c, by = y + r;
                        if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) return false;
                        if (grid[by][bx] !== 0) return false;
                    }
                }
            }
            return true;
        }

        function place(shape, x, y, color) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        grid[y + r][x + c] = 1;
                        const cell = getCell(x + c, y + r);
                        cell.style.backgroundColor = color;
                        cell.style.boxShadow = `0 0 10px ${color}`;
                        cell.style.opacity = '1';
                    }
                }
            }
            score += 10;
            scoreEl.innerText = score;
        }

        // ---- Line clearing ----
        function checkLines() {
            let linesCleared = 0;
            for (let y = 0; y < BOARD_SIZE; y++) {
                if (grid[y].every(v => v === 1)) { clearRow(y); linesCleared++; }
            }
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (grid.every(row => row[x] === 1)) { clearCol(x); linesCleared++; }
            }
            if (linesCleared > 0) {
                score += linesCleared * 100;
                scoreEl.innerText = score;
            }
        }

        function clearRow(y) {
            grid[y].fill(0);
            for (let x = 0; x < BOARD_SIZE; x++) resetCell(x, y);
        }

        function clearCol(x) {
            for (let y = 0; y < BOARD_SIZE; y++) { grid[y][x] = 0; resetCell(x, y); }
        }

        function resetCell(x, y) {
            const cell = getCell(x, y);
            cell.style.backgroundColor = '';
            cell.style.boxShadow = '';
            cell.className = 'w-full h-full bg-gray-800 rounded-sm transition-all duration-500 transform scale-0';
            setTimeout(() => { cell.className = 'w-full h-full bg-gray-800 rounded-sm'; }, 500);
        }

        // ---- Game over detection ----
        function checkGameOver() {
            if (handPieces.length === 0) return;
            for (const piece of handPieces) {
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (canPlace(piece.shape, x, y)) return; // at least one move exists
                    }
                }
            }
            // No valid moves
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').classList.remove('hidden');
        }

        function resetGame() {
            grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            score = 0;
            scoreEl.innerText = 0;
            initBoard();
            spawnBlocks();
            document.getElementById('game-over').classList.add('hidden');
        }

        initBoard();
        spawnBlocks();

    </script>

    <script src="scripts/global_translations.js?v=7.2"></script>
    <script src="scripts/spanish_translations.js?v=1.0"></script>
    <script src="scripts/hindi_translations.js?v=1.0"></script>
</body>
</html>

