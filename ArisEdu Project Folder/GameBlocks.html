<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Puzzle - Logic Challenge</title>
    <script>
        // Unlock expiration and access check
        (function() {
            const EXTEND_COST = 50;
            const EXTEND_DURATION = 50;
            
            if (sessionStorage.getItem('validGameAccess') !== 'true') {
                alert('You must access this game from the Arcade page.');
                window.location.href = 'arcade.html';
                return;
            }
            
            const expireTime = parseInt(sessionStorage.getItem('gameUnlockExpire')) || 0;
            const now = Math.floor(Date.now() / 1000);
            
            if (expireTime <= 0 || expireTime < now) {
                showExpiredPopup();
                return;
            }
            
            sessionStorage.removeItem('validGameAccess');
            
            // Set up timer to check expiration while playing
            let timeoutId = setTimeout(checkExpiration, (expireTime - now) * 1000);
            
            function checkExpiration() {
                const now = Math.floor(Date.now() / 1000);
                if (now >= expireTime) {
                    showExpiredPopup();
                }
            }
            
            function showExpiredPopup() {
                const user = JSON.parse(localStorage.getItem('user') || '{}');
                const canExtend = (user.points || 0) >= EXTEND_COST;
                
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:99999;display:flex;align-items:center;justify-content:center;';
                
                const modal = document.createElement('div');
                modal.style.cssText = 'background:white;border-radius:1rem;padding:2rem;max-width:400px;text-align:center;box-shadow:0 20px 25px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="font-size:3rem;margin-bottom:1rem;">⏱️</div>
                    <h2 style="font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#1e293b;">Session Expired!</h2>
                    <p style="margin-bottom:1.5rem;color:#64748b;">Your access time has run out.</p>
                    <div style="display:flex;gap:1rem;justify-content:center;">
                        <button id="back-to-arcade" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:1px solid #cbd5e1;background:white;color:#64748b;cursor:pointer;font-weight:600;">Back to Arcade</button>
                        ${canExtend ? 
                            `<button id="extend-session" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#f59e0b;color:#000;cursor:pointer;font-weight:600;">Extend +${EXTEND_DURATION}s (${EXTEND_COST}💎)</button>` :
                            `<button disabled style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#e2e8f0;color:#94a3b8;cursor:not-allowed;font-weight:600;">Need ${EXTEND_COST} Tokens</button>`
                        }
                    </div>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                modal.querySelector('#back-to-arcade').onclick = () => {
                    window.location.href = 'arcade.html';
                };
                
                if (canExtend) {
                    modal.querySelector('#extend-session').onclick = () => {
                        user.points = (user.points || 0) - EXTEND_COST;
                        localStorage.setItem('user', JSON.stringify(user));
                        const newExpire = Math.floor(Date.now() / 1000) + EXTEND_DURATION;
                        sessionStorage.setItem('gameUnlockExpire', newExpire);
                        overlay.remove();
                        timeoutId = setTimeout(checkExpiration, EXTEND_DURATION * 1000);
                    };
                }
            }
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        body { font-family: 'Orbitron', monospace; padding-top: 50px; }
        .grid-cell { transition: background-color 0.2s; }
        .block-shape { 
            touch-action: none; 
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .block-shape * {
            pointer-events: none;
        }
        .filled { animation: neonPulse 1.5s infinite alternate; }
        @keyframes neonPulse {
            from { box-shadow: 0 0 5px currentColor; }
            to { box-shadow: 0 0 15px currentColor; }
        }
        .fs-btn { position: absolute; bottom: 0.75rem; right: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .fs-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        .pause-btn { position: absolute; bottom: 0.75rem; left: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .pause-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        :fullscreen { background: #111827; }
        :fullscreen body { padding-top: 0 !important; }
    </style>
    <script src="theme_manager.js"></script>
</head>
<body class="dark-mode bg-gray-900 min-h-screen text-white flex flex-col items-center justify-center p-4 overflow-hidden">
<script src="scripts/taskbar.js"></script>

    <!-- Game UI -->
    <div id="game-wrapper" class="relative w-full max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
        <button class="fs-btn" onclick="toggleFS()" title="Fullscreen"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
        <button class="pause-btn" onclick="togglePause()" title="Pause"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
        <!-- Header -->
        <div class="flex justify-between items-end mb-6">
            <div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-green-400 to-emerald-600 bg-clip-text text-transparent">BLOCK PUZZLE</h1>
                <p class="text-xs text-gray-400">Clear lines to score!</p>
            </div>
            <div class="text-right">
                <div class="text-xs text-gray-400 font-sans">SCORE</div>
                <div id="score" class="text-3xl font-bold text-white">0</div>
            </div>
        </div>

        <!-- Grid Board -->
        <div id="board" class="grid grid-cols-8 gap-1 bg-gray-900 p-2 rounded-lg border-2 border-gray-700 mx-auto" style="width: 340px; height: 340px;">
            <!-- Cells generated by JS -->
        </div>

        <!-- Draggable Blocks Container -->
        <div id="hand" class="mt-8 flex justify-center gap-4 h-24 items-center min-h-[6rem]">
            <!-- Block Options -->
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-green-400 font-bold mb-2">BLOCK PUZZLE</h2>
            <p class="text-gray-300 mb-4 font-sans">Clear lines and columns to score!</p>
            <p class="text-sm text-gray-400 mb-6 font-sans">Click/Tap and drag blocks to the board. Match rows/columns!</p>
            <button onclick="startGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                START
            </button>
        </div>

        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-red-500 font-bold mb-2">GAME OVER</h2>
            <p class="text-gray-300 mb-2 font-sans">No more moves possible!</p>
            <p class="text-xs text-gray-400 mb-6 font-sans">Click & drag blocks onto board<br>P / Esc to pause</p>
            <div class="text-4xl font-bold text-white mb-8" id="final-score">0</div>
            <button onclick="resetGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                TRY AGAIN
            </button>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-30 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-4xl text-white font-bold mb-2">PAUSED</h2>
            <p class="text-xs text-gray-400 mb-6 font-sans">Click & drag blocks onto board</p>
            <p class="text-gray-400 mb-8 font-sans">Game is paused</p>
            <button onclick="togglePause()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                RESUME
            </button>
        </div>
    </div>

    <script>
        function toggleFS() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    const el = document.getElementById('game-wrapper');
                    const r = el.getBoundingClientRect();
                    const s = Math.min(window.innerWidth / r.width, window.innerHeight / r.height) * 0.88;
                    el.style.transform = `scale(${s})`;
                    el.style.transformOrigin = 'center center';
                }).catch(()=>{});
            } else { document.exitFullscreen(); }
        }
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) { const el = document.getElementById('game-wrapper'); el.style.transform = ''; }
        });

        let gamePaused = false;
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pause-screen').classList.toggle('hidden', !gamePaused);
        }
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { togglePause(); e.preventDefault(); }
        });

        const BOARD_SIZE = 8;
        let grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        let score = 0;
        const colors = ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
        
        const SHAPES = [
            [[1]],
            [[1, 1]],
            [[1, 1, 1]],
            [[1, 1, 1, 1]],
            [[1],[1]],
            [[1],[1],[1]],
            [[1],[1],[1],[1]],
            [[1, 1], [1, 1]],
            [[1, 0], [1, 1]],
            [[0, 1], [1, 1]],
            [[1, 1, 1], [0, 1, 0]],
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1, 1], [1, 1, 0]],
            [[1, 1, 1], [1, 0, 0]],
            [[1, 1, 1], [0, 0, 1]],
        ];

        const boardEl = document.getElementById('board');
        const handEl = document.getElementById('hand');
        const scoreEl = document.getElementById('score');

        // ---- Hand piece data store ----
        let handPieces = []; // [{el, shape, color}, ...]

        // ---- Drag state ----
        let dragging = null;  // {el, shape, color, ghost, offsetX, offsetY, originRect}
        let ghostCells = [];  // cells currently highlighted as preview

        // ---- Board helpers ----
        function initBoard() {
            boardEl.innerHTML = '';
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-full h-full bg-gray-800 rounded-sm';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    boardEl.appendChild(cell);
                }
            }
        }

        function getCell(x, y) {
            return boardEl.children[y * BOARD_SIZE + x];
        }

        function getBoardCellSize() {
            const rect = boardEl.getBoundingClientRect();
            // board has padding 8px (p-2) and gap 4px (gap-1)
            return (rect.width - 16) / BOARD_SIZE; // approximate cell size including gap
        }

        // ---- Spawning ----
        function spawnBlocks() {
            handEl.innerHTML = '';
            handPieces = [];
            for (let i = 0; i < 3; i++) {
                const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const color = colors[Math.floor(Math.random() * colors.length)];
                createDraggableBlock(shape, color);
            }
        }

        function createDraggableBlock(shapeMatrix, color) {
            const container = document.createElement('div');
            container.className = 'block-shape relative';
            container.style.touchAction = 'none';

            const size = 15;
            const w = shapeMatrix[0].length * size;
            const h = shapeMatrix.length * size;

            container.style.width = `${w}px`;
            container.style.height = `${h}px`;

            shapeMatrix.forEach((row, r) => {
                row.forEach((active, c) => {
                    if (active) {
                        const block = document.createElement('div');
                        block.style.cssText = `position:absolute;left:${c*size}px;top:${r*size}px;width:${size-1}px;height:${size-1}px;background:${color};border-radius:2px;pointer-events:none;`;
                        container.appendChild(block);
                    }
                });
            });

            const piece = { el: container, shape: shapeMatrix, color };
            handPieces.push(piece);

            // ---- Pointer-based drag ----
            container.addEventListener('pointerdown', (e) => {
                if (gamePaused) return;
                e.preventDefault();
                startDrag(piece, e);
            });

            handEl.appendChild(container);
        }

        // ---- Drag implementation (pointer events) ----
        function startDrag(piece, e) {
            const el = piece.el;
            const rect = el.getBoundingClientRect();

            // Create a floating ghost copy
            const ghost = el.cloneNode(true);
            ghost.style.position = 'fixed';
            ghost.style.pointerEvents = 'none';
            ghost.style.zIndex = '1000';
            ghost.style.opacity = '0.85';
            ghost.style.transform = 'scale(1.15)';
            ghost.style.transition = 'none';
            document.body.appendChild(ghost);

            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;

            ghost.style.left = (e.clientX - offsetX) + 'px';
            ghost.style.top = (e.clientY - offsetY) + 'px';

            // Dim original
            el.style.opacity = '0.3';

            dragging = { ...piece, ghost, offsetX, offsetY, originRect: rect };

            el.setPointerCapture(e.pointerId);
        }

        function onPointerMove(e) {
            if (!dragging) return;
            e.preventDefault();

            const { ghost, offsetX, offsetY } = dragging;
            ghost.style.left = (e.clientX - offsetX) + 'px';
            ghost.style.top = (e.clientY - offsetY) + 'px';

            // Board preview
            updateGhostPreview(e.clientX, e.clientY);
        }

        function onPointerUp(e) {
            if (!dragging) return;
            e.preventDefault();

            const { shape, color, ghost, el } = dragging;
            const cell = getBoardCell(e.clientX, e.clientY);
            let placed = false;

            if (cell) {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                // Offset: place so the top-left of shape aligns with hovered cell
                if (canPlace(shape, x, y)) {
                    place(shape, x, y, color);
                    placed = true;
                    // Remove piece from hand
                    el.remove();
                    handPieces = handPieces.filter(p => p.el !== el);
                    checkLines();
                    if (handPieces.length === 0) spawnBlocks();
                    checkGameOver();
                }
            }

            // Cleanup
            ghost.remove();
            clearGhostPreview();
            if (!placed) {
                el.style.opacity = '1';
            }
            dragging = null;
        }

        // Attach global listeners
        document.addEventListener('pointermove', onPointerMove, { passive: false });
        document.addEventListener('pointerup', onPointerUp, { passive: false });
        document.addEventListener('pointercancel', onPointerUp, { passive: false });

        // ---- Board cell from screen coords ----
        function getBoardCell(cx, cy) {
            const rect = boardEl.getBoundingClientRect();
            const pad = 8; // p-2 = 8px
            const innerX = cx - rect.left - pad;
            const innerY = cy - rect.top - pad;
            const cellW = (rect.width - pad * 2) / BOARD_SIZE;
            const cellH = (rect.height - pad * 2) / BOARD_SIZE;
            const gx = Math.floor(innerX / cellW);
            const gy = Math.floor(innerY / cellH);
            if (gx < 0 || gx >= BOARD_SIZE || gy < 0 || gy >= BOARD_SIZE) return null;
            return getCell(gx, gy);
        }

        // ---- Ghost preview on board ----
        function updateGhostPreview(cx, cy) {
            clearGhostPreview();
            if (!dragging) return;

            const rect = boardEl.getBoundingClientRect();
            const pad = 8;
            const cellW = (rect.width - pad * 2) / BOARD_SIZE;
            const cellH = (rect.height - pad * 2) / BOARD_SIZE;
            const innerX = cx - rect.left - pad;
            const innerY = cy - rect.top - pad;
            const gx = Math.floor(innerX / cellW);
            const gy = Math.floor(innerY / cellH);

            if (gx < 0 || gx >= BOARD_SIZE || gy < 0 || gy >= BOARD_SIZE) return;

            const { shape, color } = dragging;
            const valid = canPlace(shape, gx, gy);

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (!shape[r][c]) continue;
                    const bx = gx + c, by = gy + r;
                    if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) continue;
                    const cell = getCell(bx, by);
                    cell.dataset.prevBg = cell.style.backgroundColor || '';
                    cell.dataset.prevShadow = cell.style.boxShadow || '';
                    if (valid) {
                        cell.style.backgroundColor = color;
                        cell.style.opacity = '0.45';
                        cell.style.boxShadow = `0 0 8px ${color}`;
                    } else {
                        cell.style.backgroundColor = '#ef4444';
                        cell.style.opacity = '0.3';
                        cell.style.boxShadow = '0 0 8px #ef4444';
                    }
                    ghostCells.push(cell);
                }
            }
        }

        function clearGhostPreview() {
            ghostCells.forEach(cell => {
                cell.style.backgroundColor = cell.dataset.prevBg || '';
                cell.style.boxShadow = cell.dataset.prevShadow || '';
                cell.style.opacity = '1';
                delete cell.dataset.prevBg;
                delete cell.dataset.prevShadow;
            });
            ghostCells = [];
        }

        // ---- Placement logic ----
        function canPlace(shape, x, y) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const bx = x + c, by = y + r;
                        if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) return false;
                        if (grid[by][bx] !== 0) return false;
                    }
                }
            }
            return true;
        }

        function place(shape, x, y, color) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        grid[y + r][x + c] = 1;
                        const cell = getCell(x + c, y + r);
                        cell.style.backgroundColor = color;
                        cell.style.boxShadow = `0 0 10px ${color}`;
                        cell.style.opacity = '1';
                    }
                }
            }
            score += 10;
            scoreEl.innerText = score;
        }

        // ---- Line clearing ----
        function checkLines() {
            let linesCleared = 0;
            for (let y = 0; y < BOARD_SIZE; y++) {
                if (grid[y].every(v => v === 1)) { clearRow(y); linesCleared++; }
            }
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (grid.every(row => row[x] === 1)) { clearCol(x); linesCleared++; }
            }
            if (linesCleared > 0) {
                score += linesCleared * 100;
                scoreEl.innerText = score;
            }
        }

        function clearRow(y) {
            grid[y].fill(0);
            for (let x = 0; x < BOARD_SIZE; x++) resetCell(x, y);
        }

        function clearCol(x) {
            for (let y = 0; y < BOARD_SIZE; y++) { grid[y][x] = 0; resetCell(x, y); }
        }

        function resetCell(x, y) {
            const cell = getCell(x, y);
            cell.style.backgroundColor = '';
            cell.style.boxShadow = '';
            cell.className = 'w-full h-full bg-gray-800 rounded-sm transition-all duration-500 transform scale-0';
            setTimeout(() => { cell.className = 'w-full h-full bg-gray-800 rounded-sm'; }, 500);
        }

        // ---- Game over detection ----
        function checkGameOver() {
            if (handPieces.length === 0) return;
            for (const piece of handPieces) {
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (canPlace(piece.shape, x, y)) return; // at least one move exists
                    }
                }
            }
            // No valid moves
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').classList.remove('hidden');
        }

        function resetGame() {
            grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            score = 0;
            scoreEl.innerText = 0;
            initBoard();
            spawnBlocks();
            document.getElementById('game-over').classList.add('hidden');
        }

        initBoard();
        spawnBlocks();

    </script>

    <script src="scripts/global_translations.js?v=7.0"></script>
    <script src="scripts/spanish_translations.js?v=1.0"></script>
    <script src="scripts/hindi_translations.js?v=1.0"></script>
</body>
</html>
