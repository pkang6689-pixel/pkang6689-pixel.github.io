<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake - Arcade</title>
    <script src="firebase-utils.js"></script>
    <style>
        #game-session-timer {
            font-size: 2.5rem !important;
            font-weight: 700 !important;
        }
    </style>
    <script>
        let timerIntervalId;
        let drainIntervalId;
        
        (async function() {
            await initializeFirebase();
            
            function showOutOfTokensPopup() {
                clearInterval(timerIntervalId);
                clearInterval(drainIntervalId);
                
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:99999;display:flex;align-items:center;justify-content:center;';
                
                const modal = document.createElement('div');
                modal.style.cssText = 'background:white;border-radius:1rem;padding:2rem;max-width:400px;text-align:center;box-shadow:0 20px 25px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="font-size:3rem;margin-bottom:1rem;">💸</div>
                    <h2 style="font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#1e293b;">Out of Tokens!</h2>
                    <p style="margin-bottom:1.5rem;color:#64748b;">Your token balance hit zero.</p>
                    <p style="margin-bottom:1.5rem;color:#94a3b8;font-size:0.85rem;">Earn more tokens by completing lessons and quizzes!</p>
                    <button id="back-to-arcade" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#f59e0b;color:#000;cursor:pointer;font-weight:700;font-size:1rem;">Back to Arcade</button>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                modal.querySelector('#back-to-arcade').onclick = () => {
                    sessionStorage.removeItem('validGameAccess');
                    window.location.href = 'arcade.html';
                };
            }
            
            window.initializeTokenDrain = function() {
                const sidebar = document.getElementById('game-sidebar');
                if (!sidebar) return;
                
                let timerDisplay = document.getElementById('game-session-timer');
                if (!timerDisplay) {
                    timerDisplay = document.createElement('div');
                    timerDisplay.id = 'game-session-timer';
                    sidebar.appendChild(timerDisplay);
                }

                function updateTimerDisplay() {
                    const user = JSON.parse(localStorage.getItem('user') || '{}');
                    const remaining = Math.max(0, user.points || 0);
                    timerDisplay.textContent = remaining + '💎';
                    timerDisplay.className = remaining <= 20 ? 'warning' : '';
                    
                    if (remaining <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                function drainTokens() {
                    const user = JSON.parse(localStorage.getItem('user') || '{}');
                    const pts = user.points || 0;
                    if (pts > 0) {
                        user.points = pts - 1;
                        localStorage.setItem('user', JSON.stringify(user));
                        updateTimerDisplay();
                    } else if (pts <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                if (timerIntervalId) clearInterval(timerIntervalId);
                if (drainIntervalId) clearInterval(drainIntervalId);
                
                updateTimerDisplay();
                drainIntervalId = setInterval(drainTokens, 1000);
                
                // Pause drain when page is hidden
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        clearInterval(drainIntervalId);
                    } else {
                        drainIntervalId = setInterval(drainTokens, 1000);
                    }
                });
            };
            
            document.addEventListener('DOMContentLoaded', window.initializeTokenDrain);
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        body { font-family: 'Orbitron', monospace; padding-top: 50px; }
        canvas { border-radius: 0.5rem; }
        #game-wrapper {
            margin-left:150px;
            width: min(720px, calc(100vw - 360px));
            max-width: 100%;
        }
        #game {
            width: 100%;
            height: auto;
        }
        .pause-btn { position: absolute; bottom: 0.75rem; left: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .pause-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        :fullscreen { background: #111827; }
        
        #game-sidebar {
            background: rgba(55, 65, 81, 0.98);
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 400px;
            min-height: 800px;
            border: 2px solid rgba(107, 114, 128, 0.9);
            box-shadow: 0 20px 45px rgba(0,0,0,0.6);
        }
        #game-session-timer {
            background: rgba(34, 197, 94, 0.95);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            font-size: 2rem;
            font-family: monospace;
            width: 100%;
            text-align: center;
            margin-top: 0.5rem;
            letter-spacing: 2px;
        }
        #game-session-timer.warning {
            background: rgba(239, 68, 68, 0.95);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
    <script src="theme_manager.js"></script>
</head>
<body class="dark-mode bg-gray-900 min-h-screen text-white">
<script src="scripts/taskbar.js"></script>

<!-- Translation Scripts -->
<script src="scripts/global_translations.js?v=8.0"></script>
<script src="scripts/spanish_translations.js?v=1.0"></script>
<script src="scripts/hindi_translations.js?v=1.0"></script>

    <div class="flex flex-row items-start justify-start p-4 gap-10 overflow-x-auto overflow-y-visible">

    <div id="game-wrapper" class="relative flex-shrink-0 max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
        <button class="pause-btn" onclick="togglePause()" title="Pause"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
        <!-- Header -->
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-green-400 to-emerald-500 bg-clip-text text-transparent" data-i18n="SNAKE">SNAKE</h1>
                <p class="text-xs text-gray-400 font-sans" data-i18n="Eat apples. Don't crash!">Eat apples. Don't crash!</p>
            </div>
            <div class="text-right">
                <div class="text-xs text-gray-400 font-sans" data-i18n="SCORE">SCORE</div>
                <div id="score" class="text-3xl font-bold text-white">0</div>
            </div>
            <div class="text-right">
                <div class="text-xs text-gray-400 font-sans">BEST</div>
                <div id="best-score" class="text-3xl font-bold text-amber-400">0</div>
            </div>
        </div>

        <!-- Canvas -->
        <canvas id="game" class="bg-gray-900 border-2 border-gray-700 mx-auto block" width="340" height="340"></canvas>

        <!-- Controls info -->
        <p class="text-center text-xs text-gray-500 mt-4 font-sans" data-i18n="Arrow keys / WASD / Swipe to move">Arrow keys / WASD / Swipe to move</p>

        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-red-500 font-bold mb-2" data-i18n="GAME OVER">GAME OVER</h2>
            <p class="text-gray-300 mb-6 font-sans" data-i18n="You crashed!">You crashed!</p>
            <div class="text-4xl font-bold text-white mb-8" id="final-score">0</div>
            <button onclick="resetGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95" data-i18n="TRY AGAIN">
                TRY AGAIN
            </button>
        </div>

        <!-- Start Overlay -->
        <div id="start-screen" class="absolute inset-0 bg-black/80 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm overflow-y-auto">
            <h2 class="text-3xl text-green-400 font-bold mb-3">🐍 SNAKE</h2>
            <p class="text-gray-300 mb-3 font-sans text-sm">Eat apples to grow longer!</p>

            <!-- Settings Panel -->
            <div class="w-full max-w-xs space-y-3 mb-4">
                <!-- Speed -->
                <div class="bg-gray-800/80 rounded-lg p-3 border border-gray-700">
                    <div class="text-xs text-gray-400 font-sans mb-2">🏃 SPEED</div>
                    <div class="flex gap-2 justify-center" id="speed-options">
                        <button onclick="setSetting('speed','slow')" data-val="slow" class="setting-btn bg-gray-700 text-gray-300 text-xs py-1.5 px-3 rounded-md font-bold transition hover:bg-gray-600">Slow</button>
                        <button onclick="setSetting('speed','normal')" data-val="normal" class="setting-btn bg-green-600 text-white text-xs py-1.5 px-3 rounded-md font-bold transition ring-2 ring-green-400">Normal</button>
                        <button onclick="setSetting('speed','fast')" data-val="fast" class="setting-btn bg-gray-700 text-gray-300 text-xs py-1.5 px-3 rounded-md font-bold transition hover:bg-gray-600">Fast</button>
                        <button onclick="setSetting('speed','insane')" data-val="insane" class="setting-btn bg-gray-700 text-gray-300 text-xs py-1.5 px-3 rounded-md font-bold transition hover:bg-gray-600">Insane</button>
                    </div>
                </div>
                <!-- Apple Count -->
                <div class="bg-gray-800/80 rounded-lg p-3 border border-gray-700">
                    <div class="text-xs text-gray-400 font-sans mb-2">🍎 APPLES ON BOARD</div>
                    <div class="flex gap-2 justify-center" id="apple-options">
                        <button onclick="setSetting('apples','1')" data-val="1" class="setting-btn bg-green-600 text-white text-xs py-1.5 px-3 rounded-md font-bold transition ring-2 ring-green-400">1</button>
                        <button onclick="setSetting('apples','3')" data-val="3" class="setting-btn bg-gray-700 text-gray-300 text-xs py-1.5 px-3 rounded-md font-bold transition hover:bg-gray-600">3</button>
                        <button onclick="setSetting('apples','5')" data-val="5" class="setting-btn bg-gray-700 text-gray-300 text-xs py-1.5 px-3 rounded-md font-bold transition hover:bg-gray-600">5</button>
                    </div>
                </div>
                <!-- Grid Size -->
                <div class="bg-gray-800/80 rounded-lg p-3 border border-gray-700">
                    <div class="text-xs text-gray-400 font-sans mb-2">📐 GRID SIZE</div>
                    <div class="flex gap-2 justify-center" id="grid-options">
                        <button onclick="setSetting('grid','small')" data-val="small" class="setting-btn bg-gray-700 text-gray-300 text-xs py-1.5 px-3 rounded-md font-bold transition hover:bg-gray-600">Small</button>
                        <button onclick="setSetting('grid','normal')" data-val="normal" class="setting-btn bg-green-600 text-white text-xs py-1.5 px-3 rounded-md font-bold transition ring-2 ring-green-400">Normal</button>
                        <button onclick="setSetting('grid','large')" data-val="large" class="setting-btn bg-gray-700 text-gray-300 text-xs py-1.5 px-3 rounded-md font-bold transition hover:bg-gray-600">Large</button>
                    </div>
                </div>
            </div>

            <div class="text-left text-xs text-gray-500 font-sans mb-4 space-y-0.5">
                <p><span class="text-green-300 font-bold">Arrow Keys / WASD</span> — Move</p>
                <p><span class="text-green-300 font-bold">Swipe</span> — Move (mobile)</p>
            </div>
            <button onclick="startGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                START
            </button>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-30 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-4xl text-white font-bold mb-4" data-i18n="PAUSED">PAUSED</h2>
            <div class="text-left text-xs text-gray-400 font-sans mb-6 space-y-1">
                <p><span class="text-green-300 font-bold" data-i18n="Arrow Keys / WASD">Arrow Keys / WASD</span> — <span data-i18n="Move">Move</span></p>
                <p><span class="text-green-300 font-bold" data-i18n="Swipe">Swipe</span> — <span data-i18n="Move (mobile)">Move (mobile)</span></p>
                <p><span class="text-green-300 font-bold" data-i18n="Esc / P">Esc / P</span> — <span data-i18n="Pause">Pause</span></p>
            </div>
            <button onclick="togglePause()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95" data-i18n="RESUME">
                RESUME
            </button>
        </div>
    </div>

    <div id="game-sidebar">
        <div style="width: 100%; text-align: center; color: #9ca3af; margin-bottom: 1rem; font-size: 0.875rem; font-weight: 600;">
            SESSION
        </div>
    </div>

    </div>

    <script>
        let gamePaused = false;
        let gameRunning = false;
        let animFrame = null;
        let lastTime = 0;
        let accumulator = 0;
        let prevPositions = [];

        function togglePause() {
            if (!gameRunning && !gamePaused) return;
            gamePaused = !gamePaused;
            document.getElementById('pause-screen').classList.toggle('hidden', !gamePaused);
            if (gamePaused) {
                cancelAnimationFrame(animFrame);
                animFrame = null;
            } else {
                lastTime = 0;
                accumulator = 0;
                animFrame = requestAnimationFrame(loop);
            }
        }

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Settings (defaults)
        let settings = { speed: 'normal', apples: '1', grid: 'normal' };
        const GRID_CONFIGS = { small: {cols:12, rows:12, cell:28}, normal: {cols:17, rows:17, cell:20}, large: {cols:24, rows:24, cell:14} };
        const SPEED_CONFIGS = { slow: 130, normal: 80, fast: 50, insane: 30 };

        let GRID = 20, COLS = 17, ROWS = 17;
        let snake, dir, nextDir, score, speed;
        let apples = []; // multiple apple support
        let goldenApple = null; // rare golden apple
        let goldenTimer = 0;
        let eatParticles = [];
        let bestScore = parseInt(localStorage.getItem('snake_best') || '0');

        function setSetting(category, value) {
            settings[category] = value;
            const container = document.getElementById(category === 'speed' ? 'speed-options' : category === 'apples' ? 'apple-options' : 'grid-options');
            container.querySelectorAll('.setting-btn').forEach(btn => {
                const isSelected = btn.dataset.val === value;
                btn.className = 'setting-btn text-xs py-1.5 px-3 rounded-md font-bold transition ' +
                    (isSelected ? 'bg-green-600 text-white ring-2 ring-green-400' : 'bg-gray-700 text-gray-300 hover:bg-gray-600');
            });
        }

        function applySettings() {
            const gc = GRID_CONFIGS[settings.grid];
            COLS = gc.cols; ROWS = gc.rows; GRID = gc.cell;
            canvas.width = COLS * GRID;
            canvas.height = ROWS * GRID;
            speed = SPEED_CONFIGS[settings.speed];
        }

        function init() {
            applySettings();
            snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
            dir = {x: 1, y: 0};
            nextDir = {x: 1, y: 0};
            score = 0;
            eatParticles = [];
            prevPositions = [];
            accumulator = 0;
            lastTime = 0;
            goldenApple = null;
            goldenTimer = 0;
            apples = [];
            const appleCount = parseInt(settings.apples);
            for (let i = 0; i < appleCount; i++) placeApple();
            document.getElementById('score').textContent = '0';
            document.getElementById('best-score').textContent = bestScore;
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        function placeApple() {
            let a;
            do {
                a = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
            } while (snake.some(s => s.x === a.x && s.y === a.y) || apples.some(ap => ap.x === a.x && ap.y === a.y));
            apples.push(a);
        }

        function spawnGoldenApple() {
            if (goldenApple) return;
            let g;
            do {
                g = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
            } while (snake.some(s => s.x === g.x && s.y === g.y) || apples.some(a => a.x === g.x && a.y === g.y));
            goldenApple = g;
            goldenTimer = 80; // ticks before it disappears
        }

        function draw(interpT) {
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Subtle grid lines (much cheaper than per-cell dots)
            ctx.strokeStyle = 'rgba(255,255,255,0.025)';
            ctx.lineWidth = 0.5;
            for (let i = 1; i < COLS; i++) { ctx.beginPath(); ctx.moveTo(i*GRID, 0); ctx.lineTo(i*GRID, canvas.height); ctx.stroke(); }
            for (let j = 1; j < ROWS; j++) { ctx.beginPath(); ctx.moveTo(0, j*GRID); ctx.lineTo(canvas.width, j*GRID); ctx.stroke(); }

            // Draw all apples with glow
            const pulse = 1 + Math.sin(Date.now() / 300) * 0.08;
            apples.forEach(apple => {
                const ag = ctx.createRadialGradient(apple.x*GRID+GRID/2, apple.y*GRID+GRID/2, 0, apple.x*GRID+GRID/2, apple.y*GRID+GRID/2, GRID*1.3*pulse);
                ag.addColorStop(0, 'rgba(239,68,68,0.3)'); ag.addColorStop(1, 'rgba(239,68,68,0)');
                ctx.fillStyle = ag;
                ctx.fillRect(apple.x*GRID-GRID, apple.y*GRID-GRID, GRID*3, GRID*3);
                const ax = apple.x*GRID+GRID/2, ay = apple.y*GRID+GRID/2;
                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(ax, ay, (GRID/2-2)*pulse, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath(); ctx.arc(ax-2, ay-3, Math.max(2, GRID*0.15), 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#854d0e'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(ax, ay-GRID/2+2); ctx.lineTo(ax+1, ay-GRID/2-2); ctx.stroke();
                ctx.fillStyle = '#22c55e';
                ctx.beginPath(); ctx.ellipse(ax+3, ay-GRID/2, Math.max(2, GRID*0.14), Math.max(1.5, GRID*0.1), 0.3, 0, Math.PI*2); ctx.fill();
            });

            // Golden apple (rare bonus)
            if (goldenApple) {
                const gp = 1 + Math.sin(Date.now() / 150) * 0.12;
                const gx = goldenApple.x*GRID+GRID/2, gy = goldenApple.y*GRID+GRID/2;
                const gg = ctx.createRadialGradient(gx, gy, 0, gx, gy, GRID*1.6*gp);
                gg.addColorStop(0, 'rgba(250,204,21,0.4)'); gg.addColorStop(1, 'rgba(250,204,21,0)');
                ctx.fillStyle = gg;
                ctx.fillRect(goldenApple.x*GRID-GRID, goldenApple.y*GRID-GRID, GRID*3, GRID*3);
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath(); ctx.arc(gx, gy, (GRID/2-2)*gp, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.45)';
                ctx.beginPath(); ctx.arc(gx-2, gy-3, Math.max(2, GRID*0.15), 0, Math.PI*2); ctx.fill();
                // Star sparkle
                ctx.save(); ctx.translate(gx + GRID*0.3, gy - GRID*0.3);
                ctx.rotate(Date.now()/300); ctx.fillStyle = '#fff';
                for (let s = 0; s < 4; s++) { ctx.fillRect(-0.5, -3, 1, 6); ctx.rotate(Math.PI/4); }
                ctx.restore();
            }

            // Calculate interpolated positions for smooth movement
            const len = snake.length;
            if (len === 0) return;
            const positions = [];
            for (let i = 0; i < len; i++) {
                const curr = snake[i];
                const prev = prevPositions[i];
                if (prev && interpT < 1) {
                    positions.push({ x: lerp(prev.x, curr.x, interpT) * GRID + GRID/2, y: lerp(prev.y, curr.y, interpT) * GRID + GRID/2 });
                } else {
                    positions.push({ x: curr.x * GRID + GRID/2, y: curr.y * GRID + GRID/2 });
                }
            }

            const perpX = -dir.y, perpY = dir.x;

            // Connecting circles between segments
            for (let i = 0; i < len - 1; i++) {
                const a = positions[i], b = positions[i+1];
                const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;
                const t = i / Math.max(len-1, 1);
                const rad = (GRID/2-1.5) * (1 - t*0.35);
                const cr = Math.round(34 + (22-34)*t), cg = Math.round(197 + (101-197)*t), cb = Math.round(94 + (52-94)*t);
                ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
                ctx.beginPath(); ctx.arc(mx, my, rad*0.85, 0, Math.PI*2); ctx.fill();
            }

            // Main body circles
            for (let i = len-1; i >= 0; i--) {
                const pos = positions[i];
                const t = i / Math.max(len-1, 1);
                const radius = (GRID/2-1) * (1 - t*0.35);
                const cr = Math.round(34 + (22-34)*t), cg = Math.round(197 + (101-197)*t), cb = Math.round(94 + (52-94)*t);

                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath(); ctx.arc(pos.x+1, pos.y+1, radius, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
                ctx.beginPath(); ctx.arc(pos.x, pos.y, radius, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                ctx.beginPath(); ctx.arc(pos.x-radius*0.2, pos.y-radius*0.3, radius*0.45, 0, Math.PI*2); ctx.fill();
                if (i > 0) {
                    ctx.fillStyle = 'rgba(144,238,144,0.12)';
                    ctx.beginPath(); ctx.ellipse(pos.x, pos.y+radius*0.15, radius*0.25, radius*0.5, 0, 0, Math.PI*2); ctx.fill();
                }
            }

            // Head features (interpolated)
            const hPos = positions[0];
            const hR = GRID/2-1;
            const eDist = hR*0.45, eSize = 3.2, pSize = 1.8;
            const fX = dir.x*hR*0.35, fY = dir.y*hR*0.35;
            const leX = hPos.x+fX+perpX*eDist, leY = hPos.y+fY+perpY*eDist;
            const reX = hPos.x+fX-perpX*eDist, reY = hPos.y+fY-perpY*eDist;
            ctx.fillStyle = '#f0fdf4';
            ctx.beginPath(); ctx.arc(leX, leY, eSize, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(reX, reY, eSize, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath(); ctx.arc(leX+dir.x, leY+dir.y, pSize, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(reX+dir.x, reY+dir.y, pSize, 0, Math.PI*2); ctx.fill();

            // Flickering forked tongue
            if (Math.floor(Date.now()/200) % 3 !== 0) {
                const tX = hPos.x+dir.x*hR, tY = hPos.y+dir.y*hR;
                const tLen = 6 + Math.sin(Date.now()/100)*2;
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(tX, tY); ctx.lineTo(tX+dir.x*tLen, tY+dir.y*tLen); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(tX+dir.x*tLen, tY+dir.y*tLen); ctx.lineTo(tX+dir.x*(tLen+3)+perpX*2, tY+dir.y*(tLen+3)+perpY*2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(tX+dir.x*tLen, tY+dir.y*tLen); ctx.lineTo(tX+dir.x*(tLen+3)-perpX*2, tY+dir.y*(tLen+3)-perpY*2); ctx.stroke();
            }

            // Eat particles
            eatParticles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function update() {
            dir = nextDir;
            const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

            if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) return gameOver();
            if (snake.some(s => s.x === head.x && s.y === head.y)) return gameOver();

            snake.unshift(head);

            // Check all apples
            let ate = false;
            const eatenIdx = apples.findIndex(a => head.x === a.x && head.y === a.y);
            if (eatenIdx !== -1) {
                const eaten = apples[eatenIdx];
                score += 10;
                ate = true;
                for (let i = 0; i < 8; i++) {
                    eatParticles.push({ x: eaten.x*GRID+GRID/2, y: eaten.y*GRID+GRID/2,
                        vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4,
                        r: Math.random()*3+1, life: 15, maxLife: 15,
                        color: Math.random()>0.5 ? '#ef4444' : '#22c55e' });
                }
                apples.splice(eatenIdx, 1);
                placeApple();
                // Chance to spawn golden apple (15%)
                if (!goldenApple && Math.random() < 0.15) spawnGoldenApple();
            }

            // Check golden apple
            if (goldenApple && head.x === goldenApple.x && head.y === goldenApple.y) {
                score += 50;
                ate = true;
                for (let i = 0; i < 14; i++) {
                    eatParticles.push({ x: goldenApple.x*GRID+GRID/2, y: goldenApple.y*GRID+GRID/2,
                        vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6,
                        r: Math.random()*4+1, life: 20, maxLife: 20,
                        color: Math.random()>0.5 ? '#fbbf24' : '#fde68a' });
                }
                goldenApple = null; goldenTimer = 0;
            }

            if (ate) {
                document.getElementById('score').textContent = score;
            } else {
                snake.pop();
            }

            // Golden apple timer countdown
            if (goldenApple) {
                goldenTimer--;
                if (goldenTimer <= 0) goldenApple = null;
            }

            eatParticles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
            eatParticles = eatParticles.filter(p => p.life > 0);
        }

        function loop(timestamp) {
            if (!gameRunning) return;
            if (!lastTime) lastTime = timestamp;
            const delta = Math.min(timestamp - lastTime, 200);
            lastTime = timestamp;
            accumulator += delta;

            while (accumulator >= speed) {
                prevPositions = snake.map(s => ({x: s.x, y: s.y}));
                update();
                if (!gameRunning) { draw(1); return; }
                accumulator -= speed;
            }

            draw(accumulator / speed);
            animFrame = requestAnimationFrame(loop);
        }

        function saveBest() {
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('snake_best', bestScore);
                document.getElementById('best-score').textContent = bestScore;
            }
        }

        function gameOver() {
            gameRunning = false;
            if (animFrame) cancelAnimationFrame(animFrame);
            animFrame = null;
            gamePaused = false;
            saveBest();
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').classList.remove('hidden');
        }

        function resetGame() {
            document.getElementById('game-over').classList.add('hidden');
            init();
            draw(1);
            gameRunning = true;
            animFrame = requestAnimationFrame(loop);
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            init();
            draw(1);
            gameRunning = true;
            animFrame = requestAnimationFrame(loop);
        }

        // Keyboard
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { togglePause(); e.preventDefault(); return; }
            if (gamePaused) return;
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (dir.y !== 1) nextDir = {x:0, y:-1}; e.preventDefault(); break;
                case 'ArrowDown': case 's': case 'S':
                    if (dir.y !== -1) nextDir = {x:0, y:1}; e.preventDefault(); break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (dir.x !== 1) nextDir = {x:-1, y:0}; e.preventDefault(); break;
                case 'ArrowRight': case 'd': case 'D':
                    if (dir.x !== -1) nextDir = {x:1, y:0}; e.preventDefault(); break;
            }
        });

        // Auto-pause game (and stop timer updates) when tab loses visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (!gamePaused && gameRunning && typeof togglePause === 'function') {
                    togglePause();
                }
                if (typeof timerIntervalId !== 'undefined' && timerIntervalId) {
                    clearInterval(timerIntervalId);
                    timerIntervalId = null;
                }
            } else {
                if ((typeof timerIntervalId === 'undefined' || !timerIntervalId) && typeof window.initializeTimer === 'function') {
                    window.initializeTimer();
                }
            }
        });

        // Touch / Swipe
        let touchStart = null;
        canvas.addEventListener('touchstart', e => {
            touchStart = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        });
        canvas.addEventListener('touchend', e => {
            if (!touchStart) return;
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 20 && dir.x !== -1) nextDir = {x:1, y:0};
                else if (dx < -20 && dir.x !== 1) nextDir = {x:-1, y:0};
            } else {
                if (dy > 20 && dir.y !== -1) nextDir = {x:0, y:1};
                else if (dy < -20 && dir.y !== 1) nextDir = {x:0, y:-1};
            }
            touchStart = null;
        });

        // Initial draw
        init();
        draw(1);
    </script>
</body>
</html>

