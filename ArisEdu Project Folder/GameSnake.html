<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake - Arcade</title>
    <script>
        // Unlock expiration and access check
        let timerIntervalId;
        let gameUnlockExpire = 0;
        let timeoutId;
        
        (function() {
            const EXTEND_COST = 50;
            const EXTEND_DURATION = 50;
            const EXTEND_OPTIONS = [
                { cost: EXTEND_COST, duration: EXTEND_DURATION },
                { cost: 100, duration: 100 },
                { cost: 200, duration: 200 }
            ];
            
            if (sessionStorage.getItem('validGameAccess') !== 'true') {
                alert('You must access this game from the Arcade page.');
                window.location.href = 'arcade.html';
                return;
            }
            
            const expireTime = parseInt(sessionStorage.getItem('gameUnlockExpire')) || 0;
            const now = Math.floor(Date.now() / 1000);

            function checkExpiration() {
                const now = Math.floor(Date.now() / 1000);
                if (now >= gameUnlockExpire) {
                    showExpiredPopup();
                }
            }

            function getUser() {
                return JSON.parse(localStorage.getItem('user') || '{}');
            }

            function canAfford(cost) {
                const user = getUser();
                return (user.points || 0) >= cost;
            }

            function extendSession(cost, duration) {
                const user = getUser();
                if ((user.points || 0) < cost) {
                    return false;
                }

                user.points = (user.points || 0) - cost;
                localStorage.setItem('user', JSON.stringify(user));

                const base = Math.max(gameUnlockExpire || expireTime, Math.floor(Date.now() / 1000));
                gameUnlockExpire = base + duration;
                sessionStorage.setItem('gameUnlockExpire', gameUnlockExpire);

                if (timeoutId) clearTimeout(timeoutId);
                if (timerIntervalId) clearInterval(timerIntervalId);

                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    window.initializeTimer();
                } else {
                    document.addEventListener('DOMContentLoaded', window.initializeTimer, { once: true });
                }

                const now = Math.floor(Date.now() / 1000);
                timeoutId = setTimeout(checkExpiration, Math.max(0, gameUnlockExpire - now) * 1000);
                return true;
            }
            
            function showExpiredPopup() {
                clearInterval(timerIntervalId);
                const canExtend = canAfford(EXTEND_COST);
                
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:99999;display:flex;align-items:center;justify-content:center;';
                
                const modal = document.createElement('div');
                modal.style.cssText = 'background:white;border-radius:1rem;padding:2rem;max-width:400px;text-align:center;box-shadow:0 20px 25px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="font-size:3rem;margin-bottom:1rem;">‚è±Ô∏è</div>
                    <h2 style="font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#1e293b;">Session Expired!</h2>
                    <p style="margin-bottom:1.5rem;color:#64748b;">Your access time has run out.</p>
                    <div style="display:flex;gap:1rem;justify-content:center;">
                        <button id="back-to-arcade" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:1px solid #cbd5e1;background:white;color:#64748b;cursor:pointer;font-weight:600;">Back to Arcade</button>
                        ${canExtend ? 
                            `<button id="extend-session" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#f59e0b;color:#000;cursor:pointer;font-weight:600;">Extend +${EXTEND_DURATION}s (${EXTEND_COST}üíé)</button>` :
                            `<button disabled style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#e2e8f0;color:#94a3b8;cursor:not-allowed;font-weight:600;">Need ${EXTEND_COST} Tokens</button>`
                        }
                    </div>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                modal.querySelector('#back-to-arcade').onclick = () => {
                    window.location.href = 'arcade.html';
                };
                
                if (canExtend) {
                    modal.querySelector('#extend-session').onclick = () => {
                        if (extendSession(EXTEND_COST, EXTEND_DURATION)) {
                            overlay.remove();
                        }
                    };
                }
            }
            
            if (expireTime <= 0 || expireTime < now) {
                showExpiredPopup();
                return;
            }
            
            sessionStorage.removeItem('validGameAccess');
            gameUnlockExpire = expireTime;
            
            window.initializeTimer = function() {
                const sidebar = document.getElementById('game-sidebar');
                if (!sidebar) return;
                
                let timerDisplay = document.getElementById('game-session-timer');
                if (!timerDisplay) {
                    timerDisplay = document.createElement('div');
                    timerDisplay.id = 'game-session-timer';
                    sidebar.appendChild(timerDisplay);
                }

                // Create token-based extend buttons under the timer (once)
                let controls = document.getElementById('game-session-controls');
                if (!controls) {
                    controls = document.createElement('div');
                    controls.id = 'game-session-controls';
                    controls.style.cssText = 'margin-top:0.75rem;display:flex;flex-direction:column;gap:0.5rem;width:100%;';

                    EXTEND_OPTIONS.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.textContent = `+${opt.duration}s (${opt.cost}üíé)`;
                        btn.style.cssText = 'width:100%;padding:0.5rem 0.75rem;border-radius:0.5rem;border:none;background:#2563eb;color:white;font-weight:600;font-size:0.9rem;cursor:pointer;';
                        btn.onclick = () => {
                            if (!extendSession(opt.cost, opt.duration)) {
                                alert('Not enough tokens to add time.');
                            }
                        };
                        controls.appendChild(btn);
                    });

                    sidebar.appendChild(controls);
                }

                function updateTimerDisplay() {
                    const now = Math.floor(Date.now() / 1000);
                    const remaining = Math.max(0, gameUnlockExpire - now);
                    timerDisplay.textContent = remaining + 's';
                    timerDisplay.className = remaining <= 20 ? 'warning' : '';
                    
                    if (remaining <= 0) {
                        clearInterval(timerIntervalId);
                        showExpiredPopup();
                    }
                }
                
                if (timerIntervalId) clearInterval(timerIntervalId);
                updateTimerDisplay();
                timerIntervalId = setInterval(updateTimerDisplay, 1000);
            };
            
            // Initialize timer after DOM loads
            document.addEventListener('DOMContentLoaded', window.initializeTimer);
            
            // Set up timeout for expiration
            timeoutId = setTimeout(checkExpiration, (expireTime - now) * 1000);
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        body { font-family: 'Orbitron', monospace; padding-top: 50px; }
        canvas { border-radius: 0.5rem; }
        #game-wrapper {
            margin-left:150px;
            width: min(720px, calc(100vw - 360px));
            max-width: 100%;
        }
        #game {
            width: 100%;
            height: auto;
        }
        .pause-btn { position: absolute; bottom: 0.75rem; left: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .pause-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        :fullscreen { background: #111827; }
        
        #game-sidebar {
            position: fixed;
            top: 80px;
            right: 32px;
            background: rgba(55, 65, 81, 0.98);
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 400px;
            min-height: 800px;
            margin-right: 15rem;
            border: 2px solid rgba(107, 114, 128, 0.9);
            box-shadow: 0 20px 45px rgba(0,0,0,0.6);
            z-index: 1000;
        }
        #game-session-timer {
            background: rgba(34, 197, 94, 0.95);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            font-size: 2rem;
            font-family: monospace;
            width: 100%;
            text-align: center;
            margin-top: 0.5rem;
            letter-spacing: 2px;
        }
        #game-session-timer.warning {
            background: rgba(239, 68, 68, 0.95);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
    <script src="theme_manager.js"></script>
</head>
<body class="dark-mode bg-gray-900 min-h-screen text-white">
<script src="scripts/taskbar.js"></script>

<!-- Translation Scripts -->
<script src="scripts/global_translations.js?v=7.0"></script>
<script src="scripts/spanish_translations.js?v=1.0"></script>
<script src="scripts/hindi_translations.js?v=1.0"></script>

    <div class="flex flex-row items-start justify-start p-4 gap-10 overflow-x-auto overflow-y-visible">

    <div id="game-wrapper" class="relative flex-shrink-0 max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
        <button class="pause-btn" onclick="togglePause()" title="Pause"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
        <!-- Header -->
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-green-400 to-emerald-500 bg-clip-text text-transparent" data-i18n="SNAKE">SNAKE</h1>
                <p class="text-xs text-gray-400 font-sans" data-i18n="Eat apples. Don't crash!">Eat apples. Don't crash!</p>
            </div>
            <div class="text-right">
                <div class="text-xs text-gray-400 font-sans" data-i18n="SCORE">SCORE</div>
                <div id="score" class="text-3xl font-bold text-white">0</div>
            </div>
        </div>

        <!-- Canvas -->
        <canvas id="game" class="bg-gray-900 border-2 border-gray-700 mx-auto block" width="340" height="340"></canvas>

        <!-- Controls info -->
        <p class="text-center text-xs text-gray-500 mt-4 font-sans" data-i18n="Arrow keys / WASD / Swipe to move">Arrow keys / WASD / Swipe to move</p>

        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-red-500 font-bold mb-2" data-i18n="GAME OVER">GAME OVER</h2>
            <p class="text-gray-300 mb-6 font-sans" data-i18n="You crashed!">You crashed!</p>
            <div class="text-4xl font-bold text-white mb-8" id="final-score">0</div>
            <button onclick="resetGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95" data-i18n="TRY AGAIN">
                TRY AGAIN
            </button>
        </div>

        <!-- Start Overlay -->
        <div id="start-screen" class="absolute inset-0 bg-black/80 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-green-400 font-bold mb-4" data-i18n="üêç SNAKE">üêç SNAKE</h2>
            <p class="text-gray-300 mb-4 font-sans" data-i18n="Eat apples to grow longer!">Eat apples to grow longer!</p>
            <div class="text-left text-xs text-gray-400 font-sans mb-6 space-y-1">
                <p><span class="text-green-300 font-bold" data-i18n="Arrow Keys / WASD">Arrow Keys / WASD</span> ‚Äî <span data-i18n="Move">Move</span></p>
                <p><span class="text-green-300 font-bold" data-i18n="Swipe">Swipe</span> ‚Äî <span data-i18n="Move (mobile)">Move (mobile)</span></p>
                <p><span class="text-green-300 font-bold" data-i18n="Esc / P">Esc / P</span> ‚Äî <span data-i18n="Pause">Pause</span></p>
            </div>
            <button onclick="startGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95" data-i18n="START">
                START
            </button>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-30 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-4xl text-white font-bold mb-4" data-i18n="PAUSED">PAUSED</h2>
            <div class="text-left text-xs text-gray-400 font-sans mb-6 space-y-1">
                <p><span class="text-green-300 font-bold" data-i18n="Arrow Keys / WASD">Arrow Keys / WASD</span> ‚Äî <span data-i18n="Move">Move</span></p>
                <p><span class="text-green-300 font-bold" data-i18n="Swipe">Swipe</span> ‚Äî <span data-i18n="Move (mobile)">Move (mobile)</span></p>
                <p><span class="text-green-300 font-bold" data-i18n="Esc / P">Esc / P</span> ‚Äî <span data-i18n="Pause">Pause</span></p>
            </div>
            <button onclick="togglePause()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95" data-i18n="RESUME">
                RESUME
            </button>
        </div>
    </div>

    <div id="game-sidebar">
        <div style="width: 100%; text-align: center; color: #9ca3af; margin-bottom: 1rem; font-size: 0.875rem; font-weight: 600;">
            SESSION
        </div>
    </div>

    </div>

    <script>
        let gamePaused = false;
        let gameRunning = false;
        let animFrame = null;
        let lastTime = 0;
        let accumulator = 0;
        let prevPositions = [];

        function togglePause() {
            if (!gameRunning && !gamePaused) return;
            gamePaused = !gamePaused;
            document.getElementById('pause-screen').classList.toggle('hidden', !gamePaused);
            if (gamePaused) {
                cancelAnimationFrame(animFrame);
                animFrame = null;
            } else {
                lastTime = 0;
                accumulator = 0;
                animFrame = requestAnimationFrame(loop);
            }
        }

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const GRID = 20;
        const COLS = canvas.width / GRID;
        const ROWS = canvas.height / GRID;
        let snake, dir, nextDir, apple, score, speed;
        let eatParticles = [];

        function init() {
            snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
            dir = {x: 1, y: 0};
            nextDir = {x: 1, y: 0};
            score = 0;
            speed = 80;
            eatParticles = [];
            prevPositions = [];
            accumulator = 0;
            lastTime = 0;
            document.getElementById('score').textContent = '0';
            placeApple();
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        function placeApple() {
            do {
                apple = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
            } while (snake.some(s => s.x === apple.x && s.y === apple.y));
        }

        function draw(interpT) {
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Subtle grid lines (much cheaper than per-cell dots)
            ctx.strokeStyle = 'rgba(255,255,255,0.025)';
            ctx.lineWidth = 0.5;
            for (let i = 1; i < COLS; i++) { ctx.beginPath(); ctx.moveTo(i*GRID, 0); ctx.lineTo(i*GRID, canvas.height); ctx.stroke(); }
            for (let j = 1; j < ROWS; j++) { ctx.beginPath(); ctx.moveTo(0, j*GRID); ctx.lineTo(canvas.width, j*GRID); ctx.stroke(); }

            // Apple glow with pulse
            const pulse = 1 + Math.sin(Date.now() / 300) * 0.08;
            const ag = ctx.createRadialGradient(apple.x*GRID+GRID/2, apple.y*GRID+GRID/2, 0, apple.x*GRID+GRID/2, apple.y*GRID+GRID/2, GRID*1.3*pulse);
            ag.addColorStop(0, 'rgba(239,68,68,0.3)'); ag.addColorStop(1, 'rgba(239,68,68,0)');
            ctx.fillStyle = ag;
            ctx.fillRect(apple.x*GRID-GRID, apple.y*GRID-GRID, GRID*3, GRID*3);

            // Apple body
            const ax = apple.x*GRID+GRID/2, ay = apple.y*GRID+GRID/2;
            ctx.fillStyle = '#ef4444';
            ctx.beginPath(); ctx.arc(ax, ay, (GRID/2-2)*pulse, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath(); ctx.arc(ax-2, ay-3, 3, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#854d0e'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(ax, ay-GRID/2+2); ctx.lineTo(ax+1, ay-GRID/2-2); ctx.stroke();
            ctx.fillStyle = '#22c55e';
            ctx.beginPath(); ctx.ellipse(ax+3, ay-GRID/2, 3, 2, 0.3, 0, Math.PI*2); ctx.fill();

            // Calculate interpolated positions for smooth movement
            const len = snake.length;
            if (len === 0) return;
            const positions = [];
            for (let i = 0; i < len; i++) {
                const curr = snake[i];
                const prev = prevPositions[i];
                if (prev && interpT < 1) {
                    positions.push({ x: lerp(prev.x, curr.x, interpT) * GRID + GRID/2, y: lerp(prev.y, curr.y, interpT) * GRID + GRID/2 });
                } else {
                    positions.push({ x: curr.x * GRID + GRID/2, y: curr.y * GRID + GRID/2 });
                }
            }

            const perpX = -dir.y, perpY = dir.x;

            // Connecting circles between segments
            for (let i = 0; i < len - 1; i++) {
                const a = positions[i], b = positions[i+1];
                const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;
                const t = i / Math.max(len-1, 1);
                const rad = (GRID/2-1.5) * (1 - t*0.35);
                const cr = Math.round(34 + (22-34)*t), cg = Math.round(197 + (101-197)*t), cb = Math.round(94 + (52-94)*t);
                ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
                ctx.beginPath(); ctx.arc(mx, my, rad*0.85, 0, Math.PI*2); ctx.fill();
            }

            // Main body circles
            for (let i = len-1; i >= 0; i--) {
                const pos = positions[i];
                const t = i / Math.max(len-1, 1);
                const radius = (GRID/2-1) * (1 - t*0.35);
                const cr = Math.round(34 + (22-34)*t), cg = Math.round(197 + (101-197)*t), cb = Math.round(94 + (52-94)*t);

                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath(); ctx.arc(pos.x+1, pos.y+1, radius, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
                ctx.beginPath(); ctx.arc(pos.x, pos.y, radius, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                ctx.beginPath(); ctx.arc(pos.x-radius*0.2, pos.y-radius*0.3, radius*0.45, 0, Math.PI*2); ctx.fill();
                if (i > 0) {
                    ctx.fillStyle = 'rgba(144,238,144,0.12)';
                    ctx.beginPath(); ctx.ellipse(pos.x, pos.y+radius*0.15, radius*0.25, radius*0.5, 0, 0, Math.PI*2); ctx.fill();
                }
            }

            // Head features (interpolated)
            const hPos = positions[0];
            const hR = GRID/2-1;
            const eDist = hR*0.45, eSize = 3.2, pSize = 1.8;
            const fX = dir.x*hR*0.35, fY = dir.y*hR*0.35;
            const leX = hPos.x+fX+perpX*eDist, leY = hPos.y+fY+perpY*eDist;
            const reX = hPos.x+fX-perpX*eDist, reY = hPos.y+fY-perpY*eDist;
            ctx.fillStyle = '#f0fdf4';
            ctx.beginPath(); ctx.arc(leX, leY, eSize, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(reX, reY, eSize, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath(); ctx.arc(leX+dir.x, leY+dir.y, pSize, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(reX+dir.x, reY+dir.y, pSize, 0, Math.PI*2); ctx.fill();

            // Flickering forked tongue
            if (Math.floor(Date.now()/200) % 3 !== 0) {
                const tX = hPos.x+dir.x*hR, tY = hPos.y+dir.y*hR;
                const tLen = 6 + Math.sin(Date.now()/100)*2;
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(tX, tY); ctx.lineTo(tX+dir.x*tLen, tY+dir.y*tLen); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(tX+dir.x*tLen, tY+dir.y*tLen); ctx.lineTo(tX+dir.x*(tLen+3)+perpX*2, tY+dir.y*(tLen+3)+perpY*2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(tX+dir.x*tLen, tY+dir.y*tLen); ctx.lineTo(tX+dir.x*(tLen+3)-perpX*2, tY+dir.y*(tLen+3)-perpY*2); ctx.stroke();
            }

            // Eat particles
            eatParticles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function update() {
            dir = nextDir;
            const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

            if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) return gameOver();
            if (snake.some(s => s.x === head.x && s.y === head.y)) return gameOver();

            snake.unshift(head);

            if (head.x === apple.x && head.y === apple.y) {
                score += 10;
                document.getElementById('score').textContent = score;
                // Eat particles burst
                for (let i = 0; i < 8; i++) {
                    eatParticles.push({ x: apple.x*GRID+GRID/2, y: apple.y*GRID+GRID/2,
                        vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4,
                        r: Math.random()*3+1, life: 15, maxLife: 15,
                        color: Math.random()>0.5 ? '#ef4444' : '#22c55e' });
                }
                placeApple();
                if (speed > 55) speed -= 2;
            } else {
                snake.pop();
            }

            eatParticles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
            eatParticles = eatParticles.filter(p => p.life > 0);
        }

        function loop(timestamp) {
            if (!gameRunning) return;
            if (!lastTime) lastTime = timestamp;
            const delta = Math.min(timestamp - lastTime, 200);
            lastTime = timestamp;
            accumulator += delta;

            while (accumulator >= speed) {
                prevPositions = snake.map(s => ({x: s.x, y: s.y}));
                update();
                if (!gameRunning) { draw(1); return; }
                accumulator -= speed;
            }

            draw(accumulator / speed);
            animFrame = requestAnimationFrame(loop);
        }

        function gameOver() {
            gameRunning = false;
            if (animFrame) cancelAnimationFrame(animFrame);
            animFrame = null;
            gamePaused = false;
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').classList.remove('hidden');
        }

        function resetGame() {
            document.getElementById('game-over').classList.add('hidden');
            init();
            draw(1);
            gameRunning = true;
            animFrame = requestAnimationFrame(loop);
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            init();
            draw(1);
            gameRunning = true;
            animFrame = requestAnimationFrame(loop);
        }

        // Keyboard
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { togglePause(); e.preventDefault(); return; }
            if (gamePaused) return;
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (dir.y !== 1) nextDir = {x:0, y:-1}; e.preventDefault(); break;
                case 'ArrowDown': case 's': case 'S':
                    if (dir.y !== -1) nextDir = {x:0, y:1}; e.preventDefault(); break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (dir.x !== 1) nextDir = {x:-1, y:0}; e.preventDefault(); break;
                case 'ArrowRight': case 'd': case 'D':
                    if (dir.x !== -1) nextDir = {x:1, y:0}; e.preventDefault(); break;
            }
        });

        // Auto-pause game (and stop timer updates) when tab loses visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (!gamePaused && gameRunning && typeof togglePause === 'function') {
                    togglePause();
                }
                if (typeof timerIntervalId !== 'undefined' && timerIntervalId) {
                    clearInterval(timerIntervalId);
                    timerIntervalId = null;
                }
            } else {
                if ((typeof timerIntervalId === 'undefined' || !timerIntervalId) && typeof window.initializeTimer === 'function') {
                    window.initializeTimer();
                }
            }
        });

        // Touch / Swipe
        let touchStart = null;
        canvas.addEventListener('touchstart', e => {
            touchStart = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        });
        canvas.addEventListener('touchend', e => {
            if (!touchStart) return;
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 20 && dir.x !== -1) nextDir = {x:1, y:0};
                else if (dx < -20 && dir.x !== 1) nextDir = {x:-1, y:0};
            } else {
                if (dy > 20 && dir.y !== -1) nextDir = {x:0, y:1};
                else if (dy < -20 && dir.y !== 1) nextDir = {x:0, y:-1};
            }
            touchStart = null;
        });

        // Initial draw
        init();
        draw(1);
    </script>
</body>
</html>
