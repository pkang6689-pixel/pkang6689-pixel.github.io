<!DOCTYPE html>

<html class="h-full" lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Lesson 1.1: States of Matter</title>
<script src="/_sdk/element_sdk.js"></script>
<script src="/global_translations.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&amp;family=Playfair+Display:wght@700&amp;display=swap" rel="stylesheet"/>
<link href="/ArisEdu Project Folder/styles/main.css" rel="stylesheet"/>
<style>@view-transition { navigation: auto; }
    

</style>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&amp;display=swap" rel="stylesheet"/>
<script src="../../theme_manager.js"></script>
</head>
<body class="dark-mode h-full">
<script src="../../scripts/taskbar.js"></script>
<main class="main-container">
<div id="lesson-content-view">
<h2 class="page-title">Lesson 1.1: States of Matter</h2>
<div class="courses-container">
<div class="lesson-layout">
<div class="video-stack">
<div class="video-embed">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/gBiF-OLUVTY?start=1" title="Khan Academy Video"></iframe>
</div>
<div aria-live="polite" class="video-info-text" id="video-info-text"></div>
</div>
<div class="side-buttons">
<button class="side-button" onclick="toggleVideosPanel(this)" type="button">View other videos</button>
<div aria-hidden="true" class="videos-panel"><div class="videos-panel-title">Lesson 1.1 videos</div><div class="videos-panel-item"><a data-color-detail="#90EE90" data-color-difficulty="#7FFF00" data-color-pace="#87CEEB" data-color-speed="#87CEEB" data-rating-detail="Medium-Low" data-rating-difficulty="Easy-Medium" data-rating-pace="Fast" data-rating-speed="Fast" data-video-id="gBiF-OLUVTY" data-video-src="https://www.youtube.com/embed/gBiF-OLUVTY?start=1" data-video-title="Khan Academy" href="https://www.youtube.com/watch?v=gBiF-OLUVTY&amp;t=1s">Khan Academy</a><div aria-hidden="true" class="mini-rubric"><span style="background:#7FFF00"></span><span style="background:#90EE90"></span><span style="background:#87CEEB"></span><span style="background:#87CEEB"></span></div></div><div class="videos-panel-item"><a data-color-detail="#FFA500" data-color-difficulty="#FF6347" data-color-pace="#FF4500" data-color-speed="#FFD700" data-rating-detail="Medium-High" data-rating-difficulty="Medium-Hard" data-rating-pace="Slow" data-rating-speed="Medium" data-video-id="w1SIy56RLqI" data-video-src="https://www.youtube.com/embed/w1SIy56RLqI?start=0" data-video-title="Chem Academy" href="https://www.youtube.com/watch?v=w1SIy56RLqI&amp;t=0s">Chem Academy</a><div aria-hidden="true" class="mini-rubric"><span style="background:#FF6347"></span><span style="background:#FFA500"></span><span style="background:#FFD700"></span><span style="background:#FF4500"></span></div></div><div class="videos-panel-item"><a data-color-detail="#FFA500" data-color-difficulty="#FF6347" data-color-pace="#FF4500" data-color-speed="#87CEEB" data-rating-detail="Medium-High" data-rating-difficulty="Medium-Hard" data-rating-pace="Slow" data-rating-speed="Fast" data-video-id="9TVOlTolKFA" data-video-src="https://www.youtube.com/embed/9TVOlTolKFA?start=0" data-video-title="Organic Chemistry Tutor" href="https://www.youtube.com/watch?v=9TVOlTolKFA&amp;t=0s">Organic Chemistry Tutor</a><div aria-hidden="true" class="mini-rubric"><span style="background:#FF6347"></span><span style="background:#FFA500"></span><span style="background:#87CEEB"></span><span style="background:#FF4500"></span></div></div></div>
<a class="side-button" href="Lesson 1.1_Summary.html" style="text-align:center; text-decoration:none; display:flex; align-items: center; justify-content: center;">Next Up: Summary</a>
</div>
</div>
<div class="rubric-data" data-detail="Medium-Low" data-detail-color="#90EE90" data-difficulty="Easy-Medium" data-difficulty-color="#7FFF00" data-pace="Fast" data-pace-color="#87CEEB" data-speed="Fast" data-speed-color="#87CEEB"></div>
</div>
</div>
<!-- Embedded Summary View (Hidden by default) -->
<!-- Embedded Practice View (Hidden by default) -->
<!-- Quiz View (Hidden by default) -->
</main>
<script src="../../scripts/lesson_video.js"></script>
<!-- ArisEdu Global Search -->
<script src="../../../search_data.js"></script>
<script src="../../../search_logic.js"></script>
<script src="/ArisEdu Project Folder/scripts/game_utils.js"></script>
<script id="script-mixmatch">
(function() {
    window.initMixMatch = function() {
        if(window.mixMatchInitialized) return;
        window.mixMatchInitialized = true;
        window.startMixMatchGame();
    };

    const vocabulary = [
        { term: "Atom", def: "Basic unit of Matter" },
        { term: "Proton", def: "Positively charged particle" },
        { term: "Electron", def: "Negatively charged particle" },
        { term: "Neutron", def: "Neutral particle in nucleus" },
        { term: "Isotope", def: "Same protons, different neutrons" },
        { term: "Ion", def: "Charged atom or molecule" },
        { term: "Molecule", def: "Group of atoms bonded together" },
        { term: "Element", def: "Pure substance of one atom type" }
    ];

    let selectedCards = [];
    let matchedPairs = 0;
    let streak = 0;

    window.startMixMatchGame = function() {
        const gameContainer = document.getElementById('mixmatch-game-board');
        const winScreen = document.getElementById('mixmatch-win-screen');
        
        gameContainer.innerHTML = '';
        winScreen.classList.add('hidden');
        selectedCards = [];
        matchedPairs = 0;
        streak = 0;
        updateStreak(0);

        let gameItems = [];
        vocabulary.forEach((item, index) => {
            gameItems.push({ id: index, text: item.term, type: 'term' });
            gameItems.push({ id: index, text: item.def, type: 'def' });
        });

        gameItems.sort(() => Math.random() - 0.5).forEach(item => {
            gameContainer.appendChild(createCard(item.id, item.text, item.type));
        });
    }

    function createCard(id, text, type) {
        const div = document.createElement('div');
        div.className = 'mm-card';
        div.dataset.id = id;
        div.dataset.type = type;
        div.innerHTML = `<span class="font-semibold text-sm md:text-base">${text}</span>`;
        div.onclick = () => handleCardClick(div);
        return div;
    }

    function handleCardClick(card) {
        if (card.classList.contains('selected') || card.classList.contains('invisible')) return;
        if (selectedCards.length >= 2) return;

        card.classList.add('selected');
        selectedCards.push(card);

        if (selectedCards.length === 2) {
            checkMatch();
        }
    }

    function checkMatch() {
        const [c1, c2] = selectedCards;
        const isMatch = c1.dataset.id === c2.dataset.id && c1.dataset.type !== c2.dataset.type;

        if (isMatch) {
            setTimeout(() => {
                c1.classList.add('invisible', 'opacity-0', 'transition-opacity', 'duration-500');
                c2.classList.add('invisible', 'opacity-0', 'transition-opacity', 'duration-500');
                matchedPairs++;
                updateStreak(1);
                if (matchedPairs === vocabulary.length) {
                    setTimeout(() => document.getElementById('mixmatch-win-screen').classList.remove('hidden'), 500);
                }
            }, 300);
        } else {
            updateStreak(-streak);
            setTimeout(() => {
                [c1, c2].forEach(c => {
                    c.classList.remove('selected');
                });
            }, 800);
        }
        selectedCards = [];
    }

    function updateStreak(change) {
        streak = change === -streak ? 0 : streak + change;
        const disp = document.getElementById('mixmatch-streak-display');
        if(disp) {
            disp.textContent = streak;
            disp.classList.add('pop-anim');
            setTimeout(() => disp.classList.remove('pop-anim'), 300);
        }
    }
})();
</script><script id="script-blockpuzzle">
// Dedicated Block Puzzle Script - Completely Rewritten for Stability
// Handles Drag & Drop with strict bounds and visual feedback

(function() {
    console.log("Loading Block Puzzle Engine (v3.1 - Quiz Integrated)...");

    // --- Configuration ---
    const BOARD_SIZE = 8;
    const CELL_SIZE = 40; // Logical size for calculations, visual size depends on CSS/scaling
    const COLORS = [
        '#ef4444', // Red
        '#f59e0b', // Amber
        '#10b981', // Emerald
        '#3b82f6', // Blue
        '#8b5cf6', // Violet
        '#ec4899'  // Pink
    ];
    
    const SHAPES = [
        [[1]], // Dot
        [[1, 1]], // 2-Line H
        [[1], [1]], // 2-Line V
        [[1, 1, 1]], // 3-Line H
        [[1], [1], [1]], // 3-Line V
        [[1, 1], [1, 1]], // Square
        [[1, 0], [1, 1]], // L-small
        [[1, 1, 1], [0, 1, 0]], // T-shape
        [[1, 1, 0], [0, 1, 1]], // Z-shape inverted
        [[0, 1, 1], [1, 1, 0]], // Z-shape
        [[1, 1, 1], [1, 0, 0]], // L-Large
        [[1, 1, 1, 1]], // 4-Line H
        [[1], [1], [1], [1]] // 4-Line V 
    ];

    // --- State ---
    let grid = [];
    let score = 0;
    let isInitialized = false;
    let lastPlacement = []; // Track cells placed in the last move
    let questionsTriggered = false; // Flag to check if we should ask questions

    // --- Drag State ---
    let dragItem = null;      // The actual DOM element being dragged
    let dragData = null;      // { shape: [], color: string, startX, startY }
    let dragOffset = {x:0, y:0};
    let ghostRef = [];        // Track ghost/shadow cells on grid
    
    // --- Initialization ---
    window.initBlockPuzzle = function() {
        if (isInitialized) {
            window.resetBlockGame();
            return;
        }
        
        // Define global hook for reset
        window.resetBlockGame = resetGame;
        
        createQuestionModal(); // Setup the question modal
        
        isInitialized = true;
        initBoardUI();
        resetGame();
    };

    function createQuestionModal() {
        if (document.getElementById('bp-question-modal')) return;

        const modal = document.createElement('div');
        modal.id = 'bp-question-modal';
        modal.style.display = 'none';
        modal.className = 'fixed inset-0 z-[99999] flex items-center justify-center bg-black/90 backdrop-blur-sm';
        modal.innerHTML = `
            <style>
                @keyframes bp-shake {
                    0%, 100% { transform: translateX(0); }
                    20% { transform: translateX(-10px) rotate(-2deg); }
                    40% { transform: translateX(10px) rotate(2deg); }
                    60% { transform: translateX(-10px) rotate(-2deg); }
                    80% { transform: translateX(10px) rotate(2deg); }
                }
                @keyframes bp-pop {
                    0% { transform: scale(0.9); opacity: 0; }
                    50% { transform: scale(1.1); opacity: 1; }
                    100% { transform: scale(1); opacity: 1; }
                }
                @keyframes bp-success-pulse {
                    0% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.7); border-color: #34d399; }
                    70% { box-shadow: 0 0 0 20px rgba(52, 211, 153, 0); border-color: #34d399; }
                    100% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0); border-color: #334155; }
                }
                .bp-shake-anim { animation: bp-shake 0.5s ease-in-out; border-color: #ef4444 !important; }
                .bp-pop-anim { animation: bp-pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
                .bp-success-anim { animation: bp-success-pulse 0.8s ease-out forwards; }
            </style>
            <div id="bp-modal-box" class="bg-slate-900 p-8 rounded-2xl border border-slate-700 max-w-lg w-full shadow-2xl relative bp-pop-anim">
                <div class="text-center mb-6">
                    <h3 class="text-2xl font-bold text-white mb-2">Quiz Time!</h3>
                    <p class="text-slate-400 text-sm">Answer correctly to get more blocks.</p>
                </div>
                
                <div id="bp-q-content" class="mb-6">
                    <p id="bp-q-text" class="text-xl text-slate-100 font-medium mb-6 leading-relaxed text-center min-h-[60px] flex items-center justify-center">Loading Question...</p>
                    <div id="bp-q-options" class="grid gap-3 w-full"></div>
                </div>
                
                <div id="bp-q-feedback" class="h-8 text-center font-bold text-lg transition-all opacity-0"></div>
            </div>
        `;
        document.body.appendChild(modal);
    }

    function resetGame() {
        // Reset Grid Logic
        grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        score = 0;
        updateScore(0);
        lastPlacement = [];
        questionsTriggered = false;
        
        // Clear Board UI
        const board = document.getElementById('bp-board');
        if (board) {
            Array.from(board.children).forEach(cell => {
                cell.style.backgroundColor = '';
                cell.style.boxShadow = '';
                cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
            });
        }
        
        const go = document.getElementById('bp-game-over');
        if(go) go.classList.add('hidden');

        spawnBlocks();
    }

    function initBoardUI() {
        let boardEl = document.getElementById('bp-board');
        if (!boardEl) return;

        boardEl.innerHTML = '';
        boardEl.style.display = 'grid';
        boardEl.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
        boardEl.style.gridTemplateRows = `repeat(${BOARD_SIZE}, 1fr)`;
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                const cell = document.createElement('div');
                cell.id = `cell-${x}-${y}`;
                cell.dataset.x = x;
                cell.dataset.y = y;
                cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
                boardEl.appendChild(cell);
            }
        }
    }

    function spawnBlocks() {
        const handEl = document.getElementById('bp-hand');
        if (!handEl) return;
        
        handEl.innerHTML = '';
        
        if (questionsTriggered) {
             showQuestionModal(() => {
                 fillHand();
             });
        } else {
            questionsTriggered = true;
            fillHand();
        }
    }
    
    function fillHand() {
        const handEl = document.getElementById('bp-hand');
        if (!handEl) return;

        for (let i = 0; i < 3; i++) {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            createDraggableBlock(shape, color, handEl);
        }
    }

    // --- Quiz Logic ---
    function showQuestionModal(callback) {
        const modal = document.getElementById('bp-question-modal');
        const textEl = document.getElementById('bp-q-text');
        const optionsEl = document.getElementById('bp-q-options');
        const feedbackEl = document.getElementById('bp-q-feedback');
        
        if (!modal || !window.lessonFlashcards || window.lessonFlashcards.length === 0) {
            // console.warn("No flashcards found, skipping quiz.");
            callback();
            return;
        }
        
        modal.style.display = 'flex';
        feedbackEl.style.opacity = '0';
        optionsEl.innerHTML = ''; // Clear previous
        
        // Pick Question
        const qIndex = Math.floor(Math.random() * window.lessonFlashcards.length);
        const card = window.lessonFlashcards[qIndex];
        
        textEl.textContent = card.question;
        
        // Generate unique distractors
        let answers = new Set([card.answer]);
        const otherAnswers = [...new Set(
            window.lessonFlashcards
                .filter((_, i) => i !== qIndex)
                .map(c => c.answer)
                .filter(a => a !== card.answer)
        )];
        
        // Shuffle and pick up to 3 unique distractors
        otherAnswers.sort(() => 0.5 - Math.random());
        otherAnswers.slice(0, 3).forEach(a => answers.add(a));
        
        // Convert to array and shuffle
        answers = [...answers].sort(() => 0.5 - Math.random());
        
        answers.forEach(ans => {
            const btn = document.createElement('button');
            btn.className = 'w-full p-4 bg-slate-800 hover:bg-slate-700 text-white rounded-xl text-left transition-colors border border-slate-600 font-medium text-lg';
            btn.textContent = ans;
            btn.onclick = () => {
                const box = document.getElementById('bp-modal-box');
                
                if (ans === card.answer) {
                    // Correct
                    if(box) {
                        box.classList.remove('bp-shake-anim', 'bp-success-anim');
                        void box.offsetWidth; // Force reflow
                        box.classList.add('bp-success-anim');
                    }
                    
                    feedbackEl.textContent = "Correct! Spawning Blocks...";
                    feedbackEl.className = "h-8 text-center font-bold text-lg text-emerald-400 opacity-100";
                    setTimeout(() => {
                        modal.style.display = 'none';
                        callback();
                    }, 1000);
                } else {
                    // Wrong
                    if(box) {
                        box.classList.remove('bp-shake-anim', 'bp-success-anim');
                        void box.offsetWidth; 
                        box.classList.add('bp-shake-anim');
                    }
                    
                    feedbackEl.textContent = "Wrong! Removing blocks...";
                    feedbackEl.className = "h-8 text-center font-bold text-lg text-red-400 opacity-100";
                    
                    // Punishment: Undo last block immediately (behind modal)
                    undoLastBlock();
                    
                    // Close modal first, then show block removal, then re-open quiz
                    setTimeout(() => {
                        modal.style.display = 'none';
                        // Remove random blocks visibly on the board
                        removeRandomBlocks(3);
                        // Re-open quiz after removal animation finishes
                        setTimeout(() => {
                            showQuestionModal(callback);
                        }, 800);
                    }, 1000);
                }
            };
            optionsEl.appendChild(btn);
        });
    }
    
    function undoLastBlock() {
        if (lastPlacement.length === 0) return;
        
        lastPlacement.forEach(p => {
            grid[p.y][p.x] = 0;
            resetCell(p.x, p.y);
        });
        
        updateScore(Math.max(0, score - 10));
        lastPlacement = [];
    }
    
    function removeRandomBlocks(count) {
        // Collect all filled cells
        let filled = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (grid[y][x] === 1) filled.push({x, y});
            }
        }
        if (filled.length === 0) return;
        
        // Shuffle and pick up to `count`
        filled.sort(() => 0.5 - Math.random());
        const toRemove = filled.slice(0, Math.min(count, filled.length));
        
        toRemove.forEach(p => {
            grid[p.y][p.x] = 0;
            
            // Red flash before clearing
            const cell = document.getElementById(`cell-${p.x}-${p.y}`);
            if (cell) {
                cell.style.transition = 'background-color 0.3s, box-shadow 0.3s';
                cell.style.backgroundColor = '#ef4444';
                cell.style.boxShadow = '0 0 15px #ef4444';
                setTimeout(() => {
                    resetCell(p.x, p.y);
                    cell.style.transition = '';
                }, 400);
            }
        });
        
        updateScore(Math.max(0, score - (toRemove.length * 5)));
    }


    function createDraggableBlock(shape, color, container) {
        const BLOCK_PIXEL_SIZE = 25; 
        const GAP = 2;
        const w = shape[0].length * BLOCK_PIXEL_SIZE;
        const h = shape.length * BLOCK_PIXEL_SIZE;

        const wrapper = document.createElement('div');
        wrapper.style.width = `${w}px`;
        wrapper.style.height = `${h}px`;
        wrapper.style.position = 'relative';
        wrapper.style.cursor = 'grab';
        wrapper.style.touchAction = 'none';
        
        wrapper._shape = shape;
        wrapper._color = color;

        shape.forEach((row, r) => {
            row.forEach((filled, c) => {
                if (filled) {
                    const b = document.createElement('div');
                    b.style.position = 'absolute';
                    b.style.width = `${BLOCK_PIXEL_SIZE - GAP}px`;
                    b.style.height = `${BLOCK_PIXEL_SIZE - GAP}px`;
                    b.style.left = `${c * BLOCK_PIXEL_SIZE}px`;
                    b.style.top = `${r * BLOCK_PIXEL_SIZE}px`;
                    b.style.backgroundColor = color;
                    b.style.borderRadius = '4px';
                    b.style.pointerEvents = 'none';
                    wrapper.appendChild(b);
                }
            });
        });

        wrapper.addEventListener('mousedown', onDragStart);
        wrapper.addEventListener('touchstart', onDragStart, { passive: false });

        container.appendChild(wrapper);
    }

    // --- Drag Logic ---

    function onDragStart(e) {
        e.preventDefault(); 
        if (dragItem) return; 

        dragItem = e.currentTarget;
        const rect = dragItem.getBoundingClientRect();
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        dragOffset.x = clientX - rect.left;
        dragOffset.y = clientY - rect.top;

        dragData = {
            shape: dragItem._shape,
            color: dragItem._color,
            parent: dragItem.parentElement,
            nextSibling: dragItem.nextElementSibling,
            originalLeft: dragItem.style.left,
            originalTop: dragItem.style.top,
            originalPos: dragItem.style.position,
            startX: rect.left,
            startY: rect.top
        };

        const placeholder = document.createElement('div');
        placeholder.style.width = rect.width + 'px';
        placeholder.style.height = rect.height + 'px';
        placeholder.style.visibility = 'hidden';
        placeholder.id = 'drag-placeholder';
        
        dragItem.parentElement.insertBefore(placeholder, dragItem);
        dragData.placeholder = placeholder;

        dragItem.style.position = 'fixed';
        dragItem.style.left = (rect.left) + 'px';
        dragItem.style.top = (rect.top) + 'px';
        dragItem.style.zIndex = '9999';
        dragItem.style.pointerEvents = 'none'; 
        dragItem.style.opacity = '1';
        dragItem.style.transform = 'scale(1.1)';
        dragItem.style.cursor = 'grabbing';

        document.body.appendChild(dragItem); 

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchend', onDragEnd);
    }

    function onDragMove(e) {
        if (!dragItem) return;
        e.preventDefault();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        const x = clientX - dragOffset.x;
        const y = clientY - dragOffset.y;

        dragItem.style.left = x + 'px';
        dragItem.style.top = y + 'px';
        
        updateGhost(clientX, clientY);
    }
    
    function updateGhost(cx, cy) {
        const board = document.getElementById('bp-board');
        if (!board) return;
        
        const boardRect = board.getBoundingClientRect();
        
        // Always clear old ghost first to prevent stale shadows
        clearGhost();
        
        if (cx < boardRect.left || cx > boardRect.right || 
            cy < boardRect.top || cy > boardRect.bottom) {
            return;
        }

        const cellSize = boardRect.width / BOARD_SIZE;
        const blockRect = dragItem.getBoundingClientRect();
        const relX = blockRect.left - boardRect.left;
        const relY = blockRect.top - boardRect.top;
        
        const snap = getBestFit(dragData.shape, relX / cellSize, relY / cellSize);
        
        if (snap) {
             drawGhost(dragData.shape, snap.x, snap.y, dragData.color);
        }
    }
    
    function getBestFit(shape, fx, fy) {
        const startX = Math.floor(fx);
        const startY = Math.floor(fy);
        
        let best = null;
        let minScore = 0.85; // Snapping Tolerance

        const neighbors = [
            {x: Math.round(fx), y: Math.round(fy)}, 
            {x: Math.floor(fx), y: Math.floor(fy)},
            {x: Math.ceil(fx), y: Math.floor(fy)},
            {x: Math.floor(fx), y: Math.ceil(fy)},
            {x: Math.ceil(fx), y: Math.ceil(fy)}
        ];

        const tested = new Set();

        for (const p of neighbors) {
            const key = `${p.x},${p.y}`;
            if (tested.has(key)) continue;
            tested.add(key);

            const dist = Math.sqrt((p.x - fx) ** 2 + (p.y - fy) ** 2);
            
            if (dist < minScore && canPlace(shape, p.x, p.y)) {
                minScore = dist;
                best = p;
            }
        }
        
        return best;
    }
    
    function drawGhost(shape, x, y, color) {
        ghostRef = [];
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    const cell = document.getElementById(`cell-${x+c}-${y+r}`);
                    if (cell) {
                        cell.style.backgroundColor = color;
                        cell.style.opacity = '0.5'; 
                        cell.style.boxShadow = `inset 0 0 0 1px rgba(255,255,255,0.2)`;
                        ghostRef.push(cell);
                    }
                }
            }
        }
    }
    
    function clearGhost() {
        if (!ghostRef.length) return;
        ghostRef.forEach(cell => {
            cell.style.backgroundColor = '';
            cell.style.opacity = '';
            cell.style.boxShadow = '';
            cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
        });
        ghostRef = [];
    }

    function onDragEnd(e) {
        if (!dragItem) return;

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchend', onDragEnd);

        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

        clearGhost();

        const board = document.getElementById('bp-board');
        let placed = false;
        
        if (board) {
            const boardRect = board.getBoundingClientRect();
            if (clientX >= boardRect.left && clientX <= boardRect.right &&
                clientY >= boardRect.top && clientY <= boardRect.bottom) {
                
                const cellSize = boardRect.width / BOARD_SIZE;
                const blockRect = dragItem.getBoundingClientRect();
                const relX = blockRect.left - boardRect.left;
                const relY = blockRect.top - boardRect.top;
                
                const snap = getBestFit(dragData.shape, relX / cellSize, relY / cellSize);
                
                if (snap) {
                    placeBlock(dragData.shape, snap.x, snap.y, dragData.color);
                    placed = true;
                }
            }
        }

        if (placed) {
            dragItem.remove();
            if (dragData.placeholder) dragData.placeholder.remove();
            
            checkLines();
            
            const hand = document.getElementById('bp-hand');
            if (hand && hand.children.length === 0) {
                spawnBlocks();
            } else {
                checkGameOver();
            }
        } else {
            revertDrag();
        }

        dragItem = null;
        dragData = null;
    }

    function revertDrag() {
        const item = dragItem;
        const placeholder = dragData.placeholder;
        const parent = dragData.parent;
        const originPos = dragData.originalPos;
        const originLeft = dragData.originalLeft;
        const originTop = dragData.originalTop;
        
        const dest = placeholder.getBoundingClientRect();

        item.style.transition = "left 0.2s ease-out, top 0.2s ease-out";
        item.style.left = dest.left + 'px';
        item.style.top = dest.top + 'px';
        item.style.transform = "scale(1)"; 
        item.style.opacity = "1";
        
        setTimeout(() => {
            item.remove();
            item.style.position = originPos;
            item.style.left = originLeft;
            item.style.top = originTop;
            item.style.zIndex = '';
            item.style.pointerEvents = '';
            item.style.transform = '';
            item.style.opacity = '';
            item.style.transition = '';
            item.style.cursor = 'grab';
            item.style.filter = '';

            if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.replaceChild(item, placeholder);
            } else {
                parent.appendChild(item);
            }
            
        }, 200);
    }

    // --- Game Logic ---

    function canPlace(shape, x, y) {
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    const bx = x + c;
                    const by = y + r;
                    if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) return false;
                    if (grid[by][bx]) return false;
                }
            }
        }
        return true;
    }

    function placeBlock(shape, x, y, color) {
        lastPlacement = []; // Clear for tracking
        
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    const bx = x + c;
                    const by = y + r;
                    
                    grid[by][bx] = 1;
                    lastPlacement.push({x: bx, y: by});
                    
                    const cell = document.getElementById(`cell-${bx}-${by}`);
                    if (cell) {
                        cell.style.backgroundColor = color;
                        cell.style.boxShadow = `0 0 10px ${color}`;
                        cell.classList.remove('border-gray-700/50');
                    }
                }
            }
        }
        
        updateScore(score + 10);
    }

    function checkLines() {
        let linesCleared = 0;
        
        // Check Rows
        for (let y = 0; y < BOARD_SIZE; y++) {
            if (grid[y].every(val => val === 1)) {
                clearRow(y);
                linesCleared++;
            }
        }
        
        // Check Cols
        for (let x = 0; x < BOARD_SIZE; x++) {
            let colFilled = true;
            for (let y = 0; y < BOARD_SIZE; y++) {
                if (grid[y][x] === 0) {
                    colFilled = false;
                    break;
                }
            }
            if (colFilled) {
                clearCol(x);
                linesCleared++;
            }
        }
        
        if (linesCleared > 0) {
            updateScore(score + (linesCleared * 100) + ((linesCleared-1) * 50));
        }
    }

    function clearRow(y) {
        // Remove from undo history if clearing
        lastPlacement = lastPlacement.filter(p => p.y !== y);
        
        for (let x = 0; x < BOARD_SIZE; x++) {
            if (grid[y][x] === 1) triggerStarExplosion(x, y); 
            grid[y][x] = 0;
            resetCell(x, y);
        }
    }

    function clearCol(x) {
        // Remove from undo history if clearing
        lastPlacement = lastPlacement.filter(p => p.x !== x);
        
        for (let y = 0; y < BOARD_SIZE; y++) {
             if (grid[y][x] === 1) triggerStarExplosion(x, y);
            grid[y][x] = 0;
            resetCell(x, y);
        }
    }

    function triggerStarExplosion(x, y) {
        const cell = document.getElementById(`cell-${x}-${y}`);
        if(!cell) return;
        const rect = cell.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const color = cell.style.backgroundColor || '#fbbf24'; 

        for(let i=0; i<5; i++) {
            createValidStar(centerX, centerY, color);
        }
    }

    function createValidStar(x, y, color) {
        const star = document.createElement('div');
        star.innerHTML = `<svg viewBox="0 0 24 24" fill="${color}" width="100%" height="100%"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>`;
        star.style.position = 'fixed';
        star.style.left = (x - 10) + 'px';
        star.style.top = (y - 10) + 'px';
        star.style.width = '20px';
        star.style.height = '20px';
        star.style.pointerEvents = 'none';
        star.style.zIndex = '10001';
        star.style.transition = 'transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.6s ease-out';
        
        document.body.appendChild(star);
        
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * 60 + 30; 
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        const rot = Math.random() * 360;

        requestAnimationFrame(() => {
            star.style.transform = `translate(${tx}px, ${ty}px) rotate(${rot}deg) scale(0)`;
            star.style.opacity = '0';
        });
        
        setTimeout(() => star.remove(), 600);
    }

    function resetCell(x, y) {
        const cell = document.getElementById(`cell-${x}-${y}`);
        if (cell) {
            cell.style.backgroundColor = '';
            cell.style.boxShadow = '';
            cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
        }
    }

    function updateScore(newScore) {
        score = newScore;
        const el = document.getElementById('bp-score');
        if (el) el.textContent = score;
    }

    function checkGameOver() {
        const hand = document.getElementById('bp-hand');
        if (!hand || hand.children.length === 0) return;
        
        const shapes = Array.from(hand.children).map(wrapper => wrapper._shape);
        
        let canMove = false;
        
        for (let s = 0; s < shapes.length; s++) {
            const shape = shapes[s];
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (canPlace(shape, x, y)) {
                        canMove = true;
                        break;
                    }
                }
                if (canMove) break;
            }
            if (canMove) break;
        }
        
        if (!canMove) {
            const go = document.getElementById('bp-game-over');
            const scoreDisplay = document.getElementById('bp-final-score');
            if (go) {
                go.classList.remove('hidden');
                if(scoreDisplay) scoreDisplay.textContent = score;
            }
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.initBlockPuzzle);
    } else {
        setTimeout(window.initBlockPuzzle, 100);
    }

})();
</script><script id="script-switcher">
// Game Switcher Logic
document.addEventListener('DOMContentLoaded', () => {
    
    // Helper to hide all
    function hideAllGames() {
        const games = ['flashcard-game', 'climb-game-container', 'mixmatch-container', 'blockpuzzle-container'];
        games.forEach(id => {
            const el = document.getElementById(id);
            if(el) el.style.display = 'none';
        });
    }

    // Helper to close panel robustly
    function closePracticesPanel(linkEl) {
        const menu = linkEl.closest('.Practices-menu');
        if (menu) {
            const panel = menu.querySelector('.Practices-panel');
            if (panel) {
                panel.classList.remove('is-open');
                panel.setAttribute('aria-hidden', 'true');
            }
        }
    }

    // MixMatch Switch
    window.switchToMixMatch = function() {
        hideAllGames();
        const el = document.getElementById('mixmatch-container');
        if(el) {
            el.style.display = 'flex';
            if(window.initMixMatch) window.initMixMatch();
        }
    };

    // BlockPuzzle Switch
    window.switchToBlockPuzzle = function() {
        hideAllGames();
        const el = document.getElementById('blockpuzzle-container');
        if(el) {
            el.style.display = 'flex';
            if(window.initBlockPuzzle) window.initBlockPuzzle();
        }
    };

    // Listeners for Menu Links
    // Note: We use stopImmediatePropagation to prevent conflicts with global delegated listeners in practice_games.js
    document.querySelectorAll('a[href="#mixmatch"]').forEach(el => {
        el.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            window.switchToMixMatch();
            closePracticesPanel(el);
        });
    });

    document.querySelectorAll('a[href="#blockpuzzle"]').forEach(el => {
        el.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            window.switchToBlockPuzzle();
            closePracticesPanel(el);
        });
    });
    
    // Also patch existing Flashcards/Climb listeners to ensure they hide new games
    const oldFlash = window.switchToFlashcards;
    window.switchToFlashcards = function() {
        hideAllGames();
        const el = document.getElementById('flashcard-game');
        if(el) el.style.display = 'flex';
    };

    // Hook into Boost link if it exists and uses a global function?
    // Usually it just toggles display manually in its own listener, so hideAllGames helped.
});
</script></body></html>