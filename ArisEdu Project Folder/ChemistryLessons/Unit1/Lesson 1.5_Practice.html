<!DOCTYPE html>

<html class="h-full" lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Lesson 1.5: Heterogeneous &amp; Homogeneous Mixtures Practice</title>
<script src="/_sdk/element_sdk.js"></script>
<script src="/global_translations.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&amp;family=Playfair+Display:wght@700&amp;display=swap" rel="stylesheet"/>
<link href="/ArisEdu Project Folder/styles/main.css" rel="stylesheet"/>
<style>@view-transition { navigation: auto; }
    

</style>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&amp;display=swap" rel="stylesheet"/>
<script src="../../theme_manager.js"></script>
</head>
<body class="dark-mode h-full">
<main class="main-container">
<!-- Embedded Summary View (Hidden by default) -->
<!-- Embedded Practice View (Hidden by default) -->
<div id="practice-content-view">
<h2 class="page-title">Lesson 1.5: Heterogeneous &amp; Homogeneous Mixtures Practice</h2>
<div class="diagram-card">
<div class="flashcard-game" id="flashcard-game" style="margin-top:2rem;display:flex;flex-direction:column;align-items:center;perspective:1000px;overflow:hidden;">
<div class="flashcard-box" id="flashcard" style="background:#fff;border-radius:1rem;box-shadow:0 2px 8px rgba(0,0,0,0.12);padding:2rem 3rem;display:flex;align-items:center;justify-content:center;text-align:center;min-width:calc(320px + 56rem);min-height:calc(120px + 24rem);font-weight:600;color:#0f172a;margin-bottom:1rem;cursor:pointer;transition:background 0.2s, color 0.2s;">
<span id="flashcard-content" style="width:100%;display:block;"></span>
</div>
<div style="display:flex;gap:1rem;">
<button id="prev-flashcard" style="background:#ef4444;padding:0.75rem 1.5rem;border:none;border-radius:0.5rem;cursor:pointer;display:flex;align-items:center;justify-content:center;">
<svg fill="none" height="28" viewbox="0 0 24 24" width="28" xmlns="http://www.w3.org/2000/svg">
<path d="M15 6l-6 6 6 6" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5"></path>
</svg>
</button>
<button id="next-flashcard" style="background:#10b981;padding:0.75rem 1.5rem;border:none;border-radius:0.5rem;cursor:pointer;display:flex;align-items:center;justify-content:center;">
<svg fill="none" height="28" viewbox="0 0 24 24" width="28" xmlns="http://www.w3.org/2000/svg">
<path d="M9 6l6 6-6 6" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5"></path>
</svg>
</button>
<button id="shuffle-flashcard" title="Shuffle flashcards">
<svg fill="none" height="24" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 4h7l-1.5 1.5M20 20h-7l1.5-1.5M4 20l16-16" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
              Shuffle
            </button>
</div>
</div>
<div id="climb-game-container" style="display:none; width:100%;"> <div id="climb-game-ui" style="height: 100%; display:flex; flex-direction:column; position:relative; overflow:hidden; background-color: #e2e8f0; border-radius: 1rem; height: 64rem; font-family: 'Orbitron', sans-serif;">
<div id="climb-space-bg" style="position:absolute; top:0; left:0; width:100%; height:100%; background: radial-gradient(ellipse at bottom, #1e293b 0%, #020617 100%); z-index:0; overflow:hidden;">
<!-- Stars container -->
<div id="climb-stars" style="position:absolute; top:0; left:0; width:100%; height:100%;"></div>
<!-- Planet 1 (Greenish) -->
<div class="climb-planet" style="position:absolute; top:15%; left:10%; width:100px; height:100px; border-radius:50%; background: linear-gradient(135deg, #4ade80, #166534); box-shadow: inset -20px -20px 40px rgba(0,0,0,0.5), 0 0 20px rgba(74, 222, 128, 0.3); opacity:0.9; animation: floatPlanet 20s infinite ease-in-out;"></div>
<!-- Planet 2 (Reddish Giant) -->
<div class="climb-planet" style="position:absolute; bottom:20%; right:15%; width:180px; height:180px; border-radius:50%; background: linear-gradient(135deg, #fca5a5, #991b1b); box-shadow: inset -30px -30px 60px rgba(0,0,0,0.5), 0 0 30px rgba(248, 113, 113, 0.3); opacity:0.8; animation: floatPlanet 25s infinite ease-in-out reverse;"></div>
<!-- Planet 3 (Small Yellow Moon) -->
<div class="climb-planet" style="position:absolute; top:40%; right:30%; width:40px; height:40px; border-radius:50%; background: #fbbf24; box-shadow: 0 0 15px #fbbf24; opacity:0.9; animation: floatPlanet 15s infinite ease-in-out;"></div>
</div>
<button id="climb-fullscreen-btn" onclick="toggleClimbFullscreen()" onmouseout="this.style.transform='scale(1)'" onmouseover="this.style.transform='scale(1.1)'" style="position:absolute; bottom:1rem; right:1rem; z-index:50; background:rgba(255,255,255,0.9); border:none; border-radius:50%; width:3rem; height:3rem; cursor:pointer; box-shadow:0 4px 6px rgba(0,0,0,0.1); display:flex; align-items:center; justify-content:center; transition: transform 0.2s;" title="Toggle Fullscreen">
<svg fill="none" height="24" stroke="#334155" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2-2h3"></path></svg>
</button>
<!-- Moving Background (The Ladder) -->
<div id="climb-ladder-bg" style="position:absolute; top:0; left:0; width:100%; height:200%; background: repeating-linear-gradient(180deg, #94a3b8 0, #94a3b8 2px, transparent 2px, transparent 40px); opacity:0.3; animation: slideLadder 10s linear infinite;"></div>
<!-- Header / Status -->
<div id="climb-header" style="z-index:10; padding:1rem; background:rgba(255,255,255,0.95); display:flex; justify-content:space-between; align-items:center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
<span id="climb-score" style="font-weight: bold; color: #334155;">Score: 0</span>
<button onclick="resetToClimbMenu()" style="background:#ef4444; color:white; border:none; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor:pointer; font-weight: 600; margin-right: 0.5rem;">Restart</button>
<button id="climb-pause-btn" onclick="toggleClimbPause()" style="background:#f59e0b; color:white; border:none; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor:pointer; font-weight: 600;">Pause</button>
</div>
<!-- Game Area -->
<div style="flex:1; position:relative; width:100%; overflow:hidden;">
<!-- Fuel Bar -->
<div id="climb-fuel-text" style="position:absolute; left:2rem; bottom:calc(2rem + 605px); width:60px; text-align:center; font-weight:bold; font-size:1rem; color:#334155; white-space:nowrap; z-index:20;">Fuel Bar</div>
<div id="climb-fuel-container" style="position:absolute; bottom:2rem; left:2rem; width:60px; height:600px; background:rgba(255,255,255,0.3); border:2px solid #334155; border-radius:10px; overflow:hidden; z-index:10; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
<div id="climb-fuel-fill" style="position:absolute; bottom:0; left:0; width:100%; height:50%; background:linear-gradient(to top, #f59e0b, #ef4444); transition: height 0.5s ease;"></div>
</div>
<!-- Player -->
<div id="climb-player" style="position:absolute; bottom:35%; left:50%; transform:translateX(-50%); width:240px; height:240px; transition: bottom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 5;"><svg style="width:100%; height:100%; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));" viewbox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
<!-- Left Fin -->
<path d="M18 42 L 8 58 L 22 58 L 24 48 Z" fill="#ef4444" stroke="#991b1b" stroke-linejoin="round" stroke-width="1.5"></path>
<!-- Right Fin -->
<path d="M46 42 L 56 58 L 42 58 L 40 48 Z" fill="#ef4444" stroke="#991b1b" stroke-linejoin="round" stroke-width="1.5"></path>
<!-- Main Body -->
<ellipse cx="32" cy="32" fill="#e2e8f0" rx="14" ry="28" stroke="#475569" stroke-width="2"></ellipse>
<!-- Window -->
<circle cx="32" cy="24" fill="#3b82f6" r="7" stroke="#1d4ed8" stroke-width="1.5"></circle>
<circle cx="33" cy="22" fill="white" opacity="0.6" r="2.5"></circle>
<!-- Engine Flame -->
<path d="M26 56 Q 32 72 38 56" fill="#f59e0b" id="climb-flame-outer" stroke="#d97706" stroke-width="1" style="transform-origin: 32px 56px; transition: transform 0.1s ease-out;"></path><path d="M29 56 Q 32 66 35 56" fill="#fef3c7" id="climb-flame-inner" style="transform-origin: 32px 56px; transition: transform 0.1s ease-out;"></path>
</svg></div>
</div>
<!-- Interaction Area (Question) -->
<!-- Overlay: Start Screen -->
<div id="climb-start-screen" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:60; background:rgba(255,255,255,0.95); padding:2rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); width:80%; max-width:400px; text-align:center; border:1px solid #cbd5e1; display:flex; flex-direction:column; align-items:center;">
<h3 style="color:#1e293b; margin-top:0;">Ready to Fly?</h3>
<p style="color:#64748b; margin-bottom:1.5rem;">Answer correctly to fly up against the moving ladder!</p>
<div style="font-size:0.9rem; color:#64748b; margin-bottom:1rem;">Spacebar = Boost (Uses Fuel)<br/>Correct Answer = +Fuel</div>
<button onclick="startClimbGame()" style="background:#0f172a; color:white; padding:0.75rem 2rem; border:none; border-radius:0.5rem; cursor:pointer; font-weight:600; font-size:1.1rem; transition: background 0.2s;">Start Flying</button>
</div>
<!-- Overlay: Game Over -->
<div id="climb-game-over" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:60; background:rgba(255,255,255,0.95); padding:2rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); width:80%; max-width:400px; text-align:center; border:1px solid #cbd5e1; flex-direction:column; align-items:center;">
<h3 id="climb-result-title" style="font-size: 1.5rem; margin-bottom: 0.5rem; color:#1e293b;">Game Over!</h3>
<p id="climb-final-score" style="color:#64748b; margin-bottom: 1.5rem;"></p>
<div style="display:flex; gap:0.5rem; justify-content:center; flex-wrap:wrap;">
<button onclick="startClimbGame()" style="background:#10b981; color:white; padding:0.75rem 1.5rem; border:none; border-radius:0.5rem; cursor:pointer; font-weight:600;">Play Again</button>
<button onclick="alert('Leaderboard coming soon!')" style="background:#f59e0b; color:white; padding:0.75rem 1.5rem; border:none; border-radius:0.5rem; cursor:pointer; font-weight:600; display:flex; align-items:center; gap:0.5rem;">üèÜ Leaderboard</button>
</div>
</div>
<!-- Overlay: Pause Screen -->
<div id="climb-paused-screen" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:60; background:rgba(255,255,255,0.95); padding:2rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); width:80%; max-width:400px; text-align:center; border:1px solid #cbd5e1; flex-direction:column; align-items:center;">
<h3 style="color:#1e293b; margin-top:0;">Game Paused</h3>
<button onclick="toggleClimbPause()" style="background:#f59e0b; color:white; padding:0.75rem 2rem; border:none; border-radius:0.5rem; cursor:pointer; font-weight:600; font-size:1.1rem; transition: background 0.2s;">Resume</button>
</div>
<!-- Interaction Area (Question Only) -->
<div id="climb-interaction" style="position: absolute; position: absolute; z-index:20; background:rgba(255,255,255,0.95); padding:1.5rem; border-radius:1rem; box-shadow:0 10px 25px rgba(0,0,0,0.2); border:1px solid #cbd5e1; min-height: 200px; display:none; flex-direction:column; justify-content:center; top: 50%; right: 2rem; transform: translateY(-50%); width: 300px">
<div id="climb-question-area" style="display:block; text-align:center; width:100%; max-width:600px; margin:0 auto;">
<p id="climb-question-text" style="font-weight:bold; margin-bottom:1.5rem; font-size:1.1rem; color: #1e293b; line-height:1.5;"></p>
<div id="climb-options" style="display:grid; gap:0.75rem; grid-template-columns: 1fr;">
<!-- Buttons injected here -->
</div>
<div id="climb-feedback" style="margin-top:1rem; height:1.5rem; font-weight:bold;"></div>
</div>
</div>
<style>
                
                @keyframes twinkle { 0% { opacity:0.3; transform:scale(0.8); } 100% { opacity:1; transform:scale(1.2); } }
                @keyframes floatPlanet { 0% { transform:translateY(0px); } 50% { transform:translateY(-20px); } 100% { transform:translateY(0px); } }

@keyframes slideLadder {
                    from { background-position: 0 0; }
                    to { background-position: 0 40px; } /* Moves down 40px (one rung spacing) */
                }
                .climb-option-btn {
                    background: #f1f5f9;
                    border: 2px solid #e2e8f0;
                    padding: 0.75rem;
                    border-radius: 0.5rem;
                    cursor: pointer;
                    font-size: 1rem;
                    color: #334155;
                    transition: all 0.2s;
                    text-align: left;
                }
                .climb-option-btn:hover {
                    background: #e2e8f0;
                    border-color: #cbd5e1;
                }
            
                /* Light Mode Support (Day Sky) */
                body:not(.dark-mode) #climb-space-bg {
                    background: radial-gradient(ellipse at bottom, #bae6fd 0%, #0369a1 100%) !important;
                }
                body:not(.dark-mode) #climb-stars div {
                    opacity: 0.3 !important;
                }
                
                /* Dark Mode Support */
                body.dark-mode #climb-game-ui { background-color: #0f172a !important; }
                body.dark-mode #climb-ladder-bg { background-image: repeating-linear-gradient(180deg, #334155 0, #334155 2px, transparent 2px, transparent 40px) !important; opacity: 0.2 !important; }
                body.dark-mode #climb-header { background: rgba(15, 23, 42, 0.95) !important; box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important; }
                body.dark-mode #climb-score { color: #e2e8f0 !important; }
                body.dark-mode #climb-interaction { background: #1e293b !important; border-color: #334155 !important; }
                body.dark-mode #climb-start-screen h3, body.dark-mode #climb-game-over h3, body.dark-mode #climb-paused-screen h3 { color: #f8fafc !important; }
                body.dark-mode #climb-start-screen p, body.dark-mode #climb-game-over p, body.dark-mode #climb-question-text { color: #cbd5e1 !important; }
                body.dark-mode .climb-option-btn { background: #334155 !important; border-color: #475569 !important; color: #e2e8f0 !important; }
                body.dark-mode .climb-option-btn:hover { background: #475569 !important; border-color: #64748b !important; }
                body.dark-mode #climb-fullscreen-btn { background: rgba(30, 41, 59, 0.9) !important; }
                body.dark-mode #climb-fullscreen-btn svg { stroke: #e2e8f0 !important; }
                body.dark-mode #climb-start-screen, body.dark-mode #climb-game-over, body.dark-mode #climb-paused-screen { background: rgba(30, 41, 59, 0.95) !important; border-color: #475569 !important; }
                body.dark-mode #climb-start-screen div { color: #cbd5e1 !important; }
                body.dark-mode #climb-fuel-text { color: #e2e8f0 !important; }

</style>
</div></div>
<style>
    /* Mix & Match Styles */
    .mm-card {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 0.75rem;
      padding: 1.5rem;
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      cursor: pointer;
      font-weight: 500;
      color: #334155;
      transition: all 0.2s;
      user-select: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    body.dark-mode .mm-card {
      background: #1e293b;
      border-color: #334155;
      color: #cbd5e1;
    }
    .mm-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      border-color: #94a3b8;
      background: #f1f5f9;
    }
    body.dark-mode .mm-card:hover {
       background: #1e293b;
       border-color: #475569;
    }
    .mm-card.selected {
      background: #eff6ff;
      border-color: #3b82f6;
      color: #1d4ed8;
      transform: scale(1.02);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }
    body.dark-mode .mm-card.selected {
      background: #172554;
      border-color: #60a5fa;
      color: #bfdbfe;
    }
    .mm-card.matched {
      background: #f0fdf4;
      border-color: #22c55e;
      color: #15803d;
      opacity: 0.8;
      cursor: default;
    }
    body.dark-mode .mm-card.matched {
      background: #052e16;
      border-color: #22c55e;
      color: #86efac;
    }
    .mm-card.wrong {
      background: #fef2f2;
      border-color: #ef4444;
      animation: shake 0.5s;
    }
    body.dark-mode .mm-card.wrong {
      background: #450a0a;
      border-color: #ef4444;
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
</style>
<style>
    /* Mix & Match Styles */
    .mix-match-board {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
      margin-top: 1.5rem;
      width: 100%;
    }
    .mm-card {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 0.75rem;
      padding: 1.5rem;
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      cursor: pointer;
      font-weight: 500;
      color: #334155;
      transition: all 0.2s;
      user-select: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    body.dark-mode .mm-card {
      background: #1e293b;
      border-color: #334155;
      color: #cbd5e1;
    }
    .mm-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      border-color: #94a3b8;
      background: #f1f5f9;
    }
    body.dark-mode .mm-card:hover {
       background: #1e293b;
       border-color: #475569;
    }
    .mm-card.selected {
      background: #eff6ff;
      border-color: #3b82f6;
      color: #1d4ed8;
      transform: scale(1.02);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }
    body.dark-mode .mm-card.selected {
      background: #172554;
      border-color: #60a5fa;
      color: #bfdbfe;
    }
    .mm-card.matched {
      background: #f0fdf4;
      border-color: #22c55e;
      color: #15803d;
      opacity: 0.8;
      cursor: default;
    }
    body.dark-mode .mm-card.matched {
      background: #052e16;
      border-color: #22c55e;
      color: #86efac;
    }
    .mm-card.wrong {
      background: #fef2f2;
      border-color: #ef4444;
      animation: shake 0.5s;
    }
    body.dark-mode .mm-card.wrong {
      background: #450a0a;
      border-color: #ef4444;
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
</style>
<div id="mixmatch-container" style="display:none; flex-direction:column; align-items:center; width:100%;">
<div class="w-full max-w-4xl flex justify-between items-center mb-8">
<div>
<h1 class="text-3xl font-bold bg-gradient-to-r from-blue-400 to-cyan-300 bg-clip-text text-transparent">Mix &amp; Match</h1>
<p class="text-slate-400">Match the terms to their definitions!</p>
</div>
<div class="text-right">
<div class="text-sm text-slate-400">Streak</div>
<div class="text-2xl font-bold text-yellow-400" id="mixmatch-streak-display">0</div>
</div>
</div>
<div class="grid grid-cols-2 md:grid-cols-4 gap-4 w-full max-w-4xl" id="mixmatch-game-board">
<!-- Cards injected here -->
</div>
<div class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50" id="mixmatch-win-screen">
<div class="bg-slate-800 p-8 rounded-2xl text-center border border-slate-700 max-w-md mx-4">
<div class="text-6xl mb-4">üéâ</div>
<h2 class="text-3xl font-bold mb-2">Level Complete!</h2>
<p class="text-slate-400 mb-6">You matched all terms correctly.</p>
<button class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-full transition-all hover:scale-105 active:scale-95" onclick="window.startMixMatchGame()">
                Play Again
            </button>
</div>
</div>
</div><div id="blockpuzzle-container" style="display:none; flex-direction:column; align-items:center; justify-content:center; width:100%;">
<div class="relative w-full max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
<div class="flex justify-between items-end mb-6">
<div>
<h1 class="text-2xl font-bold bg-gradient-to-r from-green-400 to-emerald-600 bg-clip-text text-transparent">BLOCK PUZZLE</h1>
<p class="text-xs text-gray-400">Clear lines to score!</p>
</div>
<div class="text-right">
<div class="text-xs text-gray-400 font-sans">SCORE</div>
<div class="text-3xl font-bold text-white" id="bp-score">0</div>
</div>
</div>
<div class="grid grid-cols-8 gap-1 bg-gray-900 p-2 rounded-lg border-2 border-gray-700 mx-auto" id="bp-board" style="width: 340px; height: 340px;">
</div>
<div class="mt-8 flex justify-center gap-4 h-24 items-center min-h-[6rem]" id="bp-hand">
</div>
<div class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm" id="bp-game-over">
<h2 class="text-3xl text-red-500 font-bold mb-2">GAME OVER</h2>
<p class="text-gray-300 mb-6">No more moves possible!</p>
<div class="text-4xl font-bold text-white mb-8" id="bp-final-score">0</div>
<button class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95" onclick="window.resetBlockGame()">
                TRY AGAIN
            </button>
</div>
</div>
</div></div>
<div class="Practice-actions" style="margin-top:2rem;display:flex;justify-content:flex-end;width:100%;">
<div class="Practices-menu" style="position:relative; margin-right: 1rem;">
<button class="side-button view-other-Practices" onclick="togglePracticesPanel(this)" type="button">Other games</button>
<div aria-hidden="true" class="Practices-panel">
<!-- Only show flashcard game entry -->
<div class="Practices-panel-item">
<a href="#flashcard-game">Flashcard Game</a>
</div>
<div class="Practices-panel-item">
<a href="#climb">Boost</a>
</div>
<div class="Practices-panel-item"><a href="#mixmatch">Mix &amp; Match</a></div><div class="Practices-panel-item"><a href="#blockpuzzle">Block Puzzle</a></div></div>
</div>
<a class="side-button" href="Lesson 1.5_Quiz.html" style="text-align:center; text-decoration:none; display:block;">Next Up: Quiz</a>
</div>
</div>
<!-- Quiz View (Hidden by default) -->
</main>
<script src="../../scripts/lesson_video.js"></script>
<!-- Game Logic & Data -->
<script>
    window.lessonFlashcards = [
          { question: "Which state of matter has a definite shape and volume?", answer: "Solid" },
          { question: "Which state of matter has a definite volume but takes the shape of its container?", answer: "Liquid" },
          { question: "Which state of matter has no definite shape or volume?", answer: "Gas" },
          { question: "In which state do particles vibrate in fixed positions?", answer: "Solid" },
          { question: "In which state do particles move freely at high speeds?", answer: "Gas" },
          { question: "In which state do particles slide past one another?", answer: "Liquid" },
          { question: "What happens to the shape of a liquid when poured into a new container?", answer: "It takes the shape of the container" },
          { question: "Do gases have a definite volume?", answer: "No, they expand to fill the container" },
          { question: "Which state of matter is the most compressible?", answer: "Gas" },
          { question: "Which state has the strongest attraction between particles?", answer: "Solid" }
      ];
</script>
<script src="../../scripts/taskbar.js"></script>
<script src="../../scripts/practice_games.js"></script>
<script src="../../scripts/block_puzzle.js"></script>
<script id="script-mixmatch">
(function() {
    window.initMixMatch = function() {
        if(window.mixMatchInitialized) return;
        window.mixMatchInitialized = true;
        window.startMixMatchGame();
    };

    const vocabulary = [
        { term: "Atom", def: "Basic unit of Matter" },
        { term: "Proton", def: "Positively charged particle" },
        { term: "Electron", def: "Negatively charged particle" },
        { term: "Neutron", def: "Neutral particle in nucleus" },
        { term: "Isotope", def: "Same protons, different neutrons" },
        { term: "Ion", def: "Charged atom or molecule" },
        { term: "Molecule", def: "Group of atoms bonded together" },
        { term: "Element", def: "Pure substance of one atom type" }
    ];

    let selectedCards = [];
    let matchedPairs = 0;
    let streak = 0;

    window.startMixMatchGame = function() {
        const gameContainer = document.getElementById('mixmatch-game-board');
        const winScreen = document.getElementById('mixmatch-win-screen');
        
        gameContainer.innerHTML = '';
        winScreen.classList.add('hidden');
        selectedCards = [];
        matchedPairs = 0;
        streak = 0;
        updateStreak(0);

        let gameItems = [];
        vocabulary.forEach((item, index) => {
            gameItems.push({ id: index, text: item.term, type: 'term' });
            gameItems.push({ id: index, text: item.def, type: 'def' });
        });

        gameItems.sort(() => Math.random() - 0.5).forEach(item => {
            gameContainer.appendChild(createCard(item.id, item.text, item.type));
        });
    }

    function createCard(id, text, type) {
        const div = document.createElement('div');
        div.className = 'mm-card';
        div.dataset.id = id;
        div.dataset.type = type;
        div.innerHTML = `<span class="font-semibold text-sm md:text-base">${text}</span>`;
        div.onclick = () => handleCardClick(div);
        return div;
    }

    function handleCardClick(card) {
        if (card.classList.contains('selected') || card.classList.contains('invisible')) return;
        if (selectedCards.length >= 2) return;

        card.classList.add('selected');
        selectedCards.push(card);

        if (selectedCards.length === 2) {
            checkMatch();
        }
    }

    function checkMatch() {
        const [c1, c2] = selectedCards;
        const isMatch = c1.dataset.id === c2.dataset.id && c1.dataset.type !== c2.dataset.type;

        if (isMatch) {
            setTimeout(() => {
                c1.classList.add('invisible', 'opacity-0', 'transition-opacity', 'duration-500');
                c2.classList.add('invisible', 'opacity-0', 'transition-opacity', 'duration-500');
                matchedPairs++;
                updateStreak(1);
                if (matchedPairs === vocabulary.length) {
                    setTimeout(() => document.getElementById('mixmatch-win-screen').classList.remove('hidden'), 500);
                }
            }, 300);
        } else {
            updateStreak(-streak);
            setTimeout(() => {
                [c1, c2].forEach(c => {
                    c.classList.remove('selected');
                });
            }, 800);
        }
        selectedCards = [];
    }

    function updateStreak(change) {
        streak = change === -streak ? 0 : streak + change;
        const disp = document.getElementById('mixmatch-streak-display');
        if(disp) {
            disp.textContent = streak;
            disp.classList.add('pop-anim');
            setTimeout(() => disp.classList.remove('pop-anim'), 300);
        }
    }
})();
</script><script id="script-blockpuzzle">
// Dedicated Block Puzzle Script - Completely Rewritten for Stability
// Handles Drag & Drop with strict bounds and visual feedback

(function() {
    console.log("Loading Block Puzzle Engine (v3.1 - Quiz Integrated)...");

    // --- Configuration ---
    const BOARD_SIZE = 8;
    const CELL_SIZE = 40; // Logical size for calculations, visual size depends on CSS/scaling
    const COLORS = [
        '#ef4444', // Red
        '#f59e0b', // Amber
        '#10b981', // Emerald
        '#3b82f6', // Blue
        '#8b5cf6', // Violet
        '#ec4899'  // Pink
    ];
    
    const SHAPES = [
        [[1]], // Dot
        [[1, 1]], // 2-Line H
        [[1], [1]], // 2-Line V
        [[1, 1, 1]], // 3-Line H
        [[1], [1], [1]], // 3-Line V
        [[1, 1], [1, 1]], // Square
        [[1, 0], [1, 1]], // L-small
        [[1, 1, 1], [0, 1, 0]], // T-shape
        [[1, 1, 0], [0, 1, 1]], // Z-shape inverted
        [[0, 1, 1], [1, 1, 0]], // Z-shape
        [[1, 1, 1], [1, 0, 0]], // L-Large
        [[1, 1, 1, 1]], // 4-Line H
        [[1], [1], [1], [1]] // 4-Line V 
    ];

    // --- State ---
    let grid = [];
    let score = 0;
    let isInitialized = false;
    let lastPlacement = []; // Track cells placed in the last move
    let questionsTriggered = false; // Flag to check if we should ask questions

    // --- Drag State ---
    let dragItem = null;      // The actual DOM element being dragged
    let dragData = null;      // { shape: [], color: string, startX, startY }
    let dragOffset = {x:0, y:0};
    let ghostRef = [];        // Track ghost/shadow cells on grid
    
    // --- Initialization ---
    window.initBlockPuzzle = function() {
        if (isInitialized) {
            window.resetBlockGame();
            return;
        }
        
        // Define global hook for reset
        window.resetBlockGame = resetGame;
        
        createQuestionModal(); // Setup the question modal
        
        isInitialized = true;
        initBoardUI();
        resetGame();
    };

    function createQuestionModal() {
        if (document.getElementById('bp-question-modal')) return;

        const modal = document.createElement('div');
        modal.id = 'bp-question-modal';
        modal.style.display = 'none';
        modal.className = 'fixed inset-0 z-[99999] flex items-center justify-center bg-black/90 backdrop-blur-sm';
        modal.innerHTML = `
            <style>
                @keyframes bp-shake {
                    0%, 100% { transform: translateX(0); }
                    20% { transform: translateX(-10px) rotate(-2deg); }
                    40% { transform: translateX(10px) rotate(2deg); }
                    60% { transform: translateX(-10px) rotate(-2deg); }
                    80% { transform: translateX(10px) rotate(2deg); }
                }
                @keyframes bp-pop {
                    0% { transform: scale(0.9); opacity: 0; }
                    50% { transform: scale(1.1); opacity: 1; }
                    100% { transform: scale(1); opacity: 1; }
                }
                @keyframes bp-success-pulse {
                    0% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.7); border-color: #34d399; }
                    70% { box-shadow: 0 0 0 20px rgba(52, 211, 153, 0); border-color: #34d399; }
                    100% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0); border-color: #334155; }
                }
                .bp-shake-anim { animation: bp-shake 0.5s ease-in-out; border-color: #ef4444 !important; }
                .bp-pop-anim { animation: bp-pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
                .bp-success-anim { animation: bp-success-pulse 0.8s ease-out forwards; }
            </style>
            <div id="bp-modal-box" class="bg-slate-900 p-8 rounded-2xl border border-slate-700 max-w-lg w-full shadow-2xl relative bp-pop-anim">
                <div class="text-center mb-6">
                    <h3 class="text-2xl font-bold text-white mb-2">Quiz Time!</h3>
                    <p class="text-slate-400 text-sm">Answer correctly to get more blocks.</p>
                </div>
                
                <div id="bp-q-content" class="mb-6">
                    <p id="bp-q-text" class="text-xl text-slate-100 font-medium mb-6 leading-relaxed text-center min-h-[60px] flex items-center justify-center">Loading Question...</p>
                    <div id="bp-q-options" class="grid gap-3 w-full"></div>
                </div>
                
                <div id="bp-q-feedback" class="h-8 text-center font-bold text-lg transition-all opacity-0"></div>
            </div>
        `;
        document.body.appendChild(modal);
    }

    function resetGame() {
        // Reset Grid Logic
        grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        score = 0;
        updateScore(0);
        lastPlacement = [];
        questionsTriggered = false;
        
        // Clear Board UI
        const board = document.getElementById('bp-board');
        if (board) {
            Array.from(board.children).forEach(cell => {
                cell.style.backgroundColor = '';
                cell.style.boxShadow = '';
                cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
            });
        }
        
        const go = document.getElementById('bp-game-over');
        if(go) go.classList.add('hidden');

        spawnBlocks();
    }

    function initBoardUI() {
        let boardEl = document.getElementById('bp-board');
        if (!boardEl) return;

        boardEl.innerHTML = '';
        boardEl.style.display = 'grid';
        boardEl.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
        boardEl.style.gridTemplateRows = `repeat(${BOARD_SIZE}, 1fr)`;
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                const cell = document.createElement('div');
                cell.id = `cell-${x}-${y}`;
                cell.dataset.x = x;
                cell.dataset.y = y;
                cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
                boardEl.appendChild(cell);
            }
        }
    }

    function spawnBlocks() {
        const handEl = document.getElementById('bp-hand');
        if (!handEl) return;
        
        handEl.innerHTML = '';
        
        if (questionsTriggered) {
             showQuestionModal(() => {
                 fillHand();
             });
        } else {
            questionsTriggered = true;
            fillHand();
        }
    }
    
    function fillHand() {
        const handEl = document.getElementById('bp-hand');
        if (!handEl) return;

        for (let i = 0; i < 3; i++) {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            createDraggableBlock(shape, color, handEl);
        }
    }

    // --- Quiz Logic ---
    function showQuestionModal(callback) {
        const modal = document.getElementById('bp-question-modal');
        const textEl = document.getElementById('bp-q-text');
        const optionsEl = document.getElementById('bp-q-options');
        const feedbackEl = document.getElementById('bp-q-feedback');
        
        if (!modal || !window.lessonFlashcards || window.lessonFlashcards.length === 0) {
            // console.warn("No flashcards found, skipping quiz.");
            callback();
            return;
        }
        
        modal.style.display = 'flex';
        feedbackEl.style.opacity = '0';
        optionsEl.innerHTML = ''; // Clear previous
        
        // Pick Question
        const qIndex = Math.floor(Math.random() * window.lessonFlashcards.length);
        const card = window.lessonFlashcards[qIndex];
        
        textEl.textContent = card.question;
        
        // Generate unique distractors
        let answers = new Set([card.answer]);
        const otherAnswers = [...new Set(
            window.lessonFlashcards
                .filter((_, i) => i !== qIndex)
                .map(c => c.answer)
                .filter(a => a !== card.answer)
        )];
        
        // Shuffle and pick up to 3 unique distractors
        otherAnswers.sort(() => 0.5 - Math.random());
        otherAnswers.slice(0, 3).forEach(a => answers.add(a));
        
        // Convert to array and shuffle
        answers = [...answers].sort(() => 0.5 - Math.random());
        
        answers.forEach(ans => {
            const btn = document.createElement('button');
            btn.className = 'w-full p-4 bg-slate-800 hover:bg-slate-700 text-white rounded-xl text-left transition-colors border border-slate-600 font-medium text-lg';
            btn.textContent = ans;
            btn.onclick = () => {
                const box = document.getElementById('bp-modal-box');
                
                if (ans === card.answer) {
                    // Correct
                    if(box) {
                        box.classList.remove('bp-shake-anim', 'bp-success-anim');
                        void box.offsetWidth; // Force reflow
                        box.classList.add('bp-success-anim');
                    }
                    
                    feedbackEl.textContent = "Correct! Spawning Blocks...";
                    feedbackEl.className = "h-8 text-center font-bold text-lg text-emerald-400 opacity-100";
                    setTimeout(() => {
                        modal.style.display = 'none';
                        callback();
                    }, 1000);
                } else {
                    // Wrong
                    if(box) {
                        box.classList.remove('bp-shake-anim', 'bp-success-anim');
                        void box.offsetWidth; 
                        box.classList.add('bp-shake-anim');
                    }
                    
                    feedbackEl.textContent = "Wrong! Removing blocks...";
                    feedbackEl.className = "h-8 text-center font-bold text-lg text-red-400 opacity-100";
                    
                    // Punishment: Undo last block immediately (behind modal)
                    undoLastBlock();
                    
                    // Close modal first, then show block removal, then re-open quiz
                    setTimeout(() => {
                        modal.style.display = 'none';
                        // Remove random blocks visibly on the board
                        removeRandomBlocks(3);
                        // Re-open quiz after removal animation finishes
                        setTimeout(() => {
                            showQuestionModal(callback);
                        }, 800);
                    }, 1000);
                }
            };
            optionsEl.appendChild(btn);
        });
    }
    
    function undoLastBlock() {
        if (lastPlacement.length === 0) return;
        
        lastPlacement.forEach(p => {
            grid[p.y][p.x] = 0;
            resetCell(p.x, p.y);
        });
        
        updateScore(Math.max(0, score - 10));
        lastPlacement = [];
    }
    
    function removeRandomBlocks(count) {
        // Collect all filled cells
        let filled = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (grid[y][x] === 1) filled.push({x, y});
            }
        }
        if (filled.length === 0) return;
        
        // Shuffle and pick up to `count`
        filled.sort(() => 0.5 - Math.random());
        const toRemove = filled.slice(0, Math.min(count, filled.length));
        
        toRemove.forEach(p => {
            grid[p.y][p.x] = 0;
            
            // Red flash before clearing
            const cell = document.getElementById(`cell-${p.x}-${p.y}`);
            if (cell) {
                cell.style.transition = 'background-color 0.3s, box-shadow 0.3s';
                cell.style.backgroundColor = '#ef4444';
                cell.style.boxShadow = '0 0 15px #ef4444';
                setTimeout(() => {
                    resetCell(p.x, p.y);
                    cell.style.transition = '';
                }, 400);
            }
        });
        
        updateScore(Math.max(0, score - (toRemove.length * 5)));
    }


    function createDraggableBlock(shape, color, container) {
        const BLOCK_PIXEL_SIZE = 25; 
        const GAP = 2;
        const w = shape[0].length * BLOCK_PIXEL_SIZE;
        const h = shape.length * BLOCK_PIXEL_SIZE;

        const wrapper = document.createElement('div');
        wrapper.style.width = `${w}px`;
        wrapper.style.height = `${h}px`;
        wrapper.style.position = 'relative';
        wrapper.style.cursor = 'grab';
        wrapper.style.touchAction = 'none';
        
        wrapper._shape = shape;
        wrapper._color = color;

        shape.forEach((row, r) => {
            row.forEach((filled, c) => {
                if (filled) {
                    const b = document.createElement('div');
                    b.style.position = 'absolute';
                    b.style.width = `${BLOCK_PIXEL_SIZE - GAP}px`;
                    b.style.height = `${BLOCK_PIXEL_SIZE - GAP}px`;
                    b.style.left = `${c * BLOCK_PIXEL_SIZE}px`;
                    b.style.top = `${r * BLOCK_PIXEL_SIZE}px`;
                    b.style.backgroundColor = color;
                    b.style.borderRadius = '4px';
                    b.style.pointerEvents = 'none';
                    wrapper.appendChild(b);
                }
            });
        });

        wrapper.addEventListener('mousedown', onDragStart);
        wrapper.addEventListener('touchstart', onDragStart, { passive: false });

        container.appendChild(wrapper);
    }

    // --- Drag Logic ---

    function onDragStart(e) {
        e.preventDefault(); 
        if (dragItem) return; 

        dragItem = e.currentTarget;
        const rect = dragItem.getBoundingClientRect();
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        dragOffset.x = clientX - rect.left;
        dragOffset.y = clientY - rect.top;

        dragData = {
            shape: dragItem._shape,
            color: dragItem._color,
            parent: dragItem.parentElement,
            nextSibling: dragItem.nextElementSibling,
            originalLeft: dragItem.style.left,
            originalTop: dragItem.style.top,
            originalPos: dragItem.style.position,
            startX: rect.left,
            startY: rect.top
        };

        const placeholder = document.createElement('div');
        placeholder.style.width = rect.width + 'px';
        placeholder.style.height = rect.height + 'px';
        placeholder.style.visibility = 'hidden';
        placeholder.id = 'drag-placeholder';
        
        dragItem.parentElement.insertBefore(placeholder, dragItem);
        dragData.placeholder = placeholder;

        dragItem.style.position = 'fixed';
        dragItem.style.left = (rect.left) + 'px';
        dragItem.style.top = (rect.top) + 'px';
        dragItem.style.zIndex = '9999';
        dragItem.style.pointerEvents = 'none'; 
        dragItem.style.opacity = '1';
        dragItem.style.transform = 'scale(1.1)';
        dragItem.style.cursor = 'grabbing';

        document.body.appendChild(dragItem); 

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchend', onDragEnd);
    }

    function onDragMove(e) {
        if (!dragItem) return;
        e.preventDefault();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        const x = clientX - dragOffset.x;
        const y = clientY - dragOffset.y;

        dragItem.style.left = x + 'px';
        dragItem.style.top = y + 'px';
        
        updateGhost(clientX, clientY);
    }
    
    function updateGhost(cx, cy) {
        const board = document.getElementById('bp-board');
        if (!board) return;
        
        const boardRect = board.getBoundingClientRect();
        
        // Always clear old ghost first to prevent stale shadows
        clearGhost();
        
        if (cx < boardRect.left || cx > boardRect.right || 
            cy < boardRect.top || cy > boardRect.bottom) {
            return;
        }

        const cellSize = boardRect.width / BOARD_SIZE;
        const blockRect = dragItem.getBoundingClientRect();
        const relX = blockRect.left - boardRect.left;
        const relY = blockRect.top - boardRect.top;
        
        const snap = getBestFit(dragData.shape, relX / cellSize, relY / cellSize);
        
        if (snap) {
             drawGhost(dragData.shape, snap.x, snap.y, dragData.color);
        }
    }
    
    function getBestFit(shape, fx, fy) {
        const startX = Math.floor(fx);
        const startY = Math.floor(fy);
        
        let best = null;
        let minScore = 0.85; // Snapping Tolerance

        const neighbors = [
            {x: Math.round(fx), y: Math.round(fy)}, 
            {x: Math.floor(fx), y: Math.floor(fy)},
            {x: Math.ceil(fx), y: Math.floor(fy)},
            {x: Math.floor(fx), y: Math.ceil(fy)},
            {x: Math.ceil(fx), y: Math.ceil(fy)}
        ];

        const tested = new Set();

        for (const p of neighbors) {
            const key = `${p.x},${p.y}`;
            if (tested.has(key)) continue;
            tested.add(key);

            const dist = Math.sqrt((p.x - fx) ** 2 + (p.y - fy) ** 2);
            
            if (dist < minScore && canPlace(shape, p.x, p.y)) {
                minScore = dist;
                best = p;
            }
        }
        
        return best;
    }
    
    function drawGhost(shape, x, y, color) {
        ghostRef = [];
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    const cell = document.getElementById(`cell-${x+c}-${y+r}`);
                    if (cell) {
                        cell.style.backgroundColor = color;
                        cell.style.opacity = '0.5'; 
                        cell.style.boxShadow = `inset 0 0 0 1px rgba(255,255,255,0.2)`;
                        ghostRef.push(cell);
                    }
                }
            }
        }
    }
    
    function clearGhost() {
        if (!ghostRef.length) return;
        ghostRef.forEach(cell => {
            cell.style.backgroundColor = '';
            cell.style.opacity = '';
            cell.style.boxShadow = '';
            cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
        });
        ghostRef = [];
    }

    function onDragEnd(e) {
        if (!dragItem) return;

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchend', onDragEnd);

        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

        clearGhost();

        const board = document.getElementById('bp-board');
        let placed = false;
        
        if (board) {
            const boardRect = board.getBoundingClientRect();
            if (clientX >= boardRect.left && clientX <= boardRect.right &&
                clientY >= boardRect.top && clientY <= boardRect.bottom) {
                
                const cellSize = boardRect.width / BOARD_SIZE;
                const blockRect = dragItem.getBoundingClientRect();
                const relX = blockRect.left - boardRect.left;
                const relY = blockRect.top - boardRect.top;
                
                const snap = getBestFit(dragData.shape, relX / cellSize, relY / cellSize);
                
                if (snap) {
                    placeBlock(dragData.shape, snap.x, snap.y, dragData.color);
                    placed = true;
                }
            }
        }

        if (placed) {
            dragItem.remove();
            if (dragData.placeholder) dragData.placeholder.remove();
            
            checkLines();
            
            const hand = document.getElementById('bp-hand');
            if (hand && hand.children.length === 0) {
                spawnBlocks();
            } else {
                checkGameOver();
            }
        } else {
            revertDrag();
        }

        dragItem = null;
        dragData = null;
    }

    function revertDrag() {
        const item = dragItem;
        const placeholder = dragData.placeholder;
        const parent = dragData.parent;
        const originPos = dragData.originalPos;
        const originLeft = dragData.originalLeft;
        const originTop = dragData.originalTop;
        
        const dest = placeholder.getBoundingClientRect();

        item.style.transition = "left 0.2s ease-out, top 0.2s ease-out";
        item.style.left = dest.left + 'px';
        item.style.top = dest.top + 'px';
        item.style.transform = "scale(1)"; 
        item.style.opacity = "1";
        
        setTimeout(() => {
            item.remove();
            item.style.position = originPos;
            item.style.left = originLeft;
            item.style.top = originTop;
            item.style.zIndex = '';
            item.style.pointerEvents = '';
            item.style.transform = '';
            item.style.opacity = '';
            item.style.transition = '';
            item.style.cursor = 'grab';
            item.style.filter = '';

            if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.replaceChild(item, placeholder);
            } else {
                parent.appendChild(item);
            }
            
        }, 200);
    }

    // --- Game Logic ---

    function canPlace(shape, x, y) {
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    const bx = x + c;
                    const by = y + r;
                    if (bx < 0 || bx >= BOARD_SIZE || by < 0 || by >= BOARD_SIZE) return false;
                    if (grid[by][bx]) return false;
                }
            }
        }
        return true;
    }

    function placeBlock(shape, x, y, color) {
        lastPlacement = []; // Clear for tracking
        
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    const bx = x + c;
                    const by = y + r;
                    
                    grid[by][bx] = 1;
                    lastPlacement.push({x: bx, y: by});
                    
                    const cell = document.getElementById(`cell-${bx}-${by}`);
                    if (cell) {
                        cell.style.backgroundColor = color;
                        cell.style.boxShadow = `0 0 10px ${color}`;
                        cell.classList.remove('border-gray-700/50');
                    }
                }
            }
        }
        
        updateScore(score + 10);
    }

    function checkLines() {
        let linesCleared = 0;
        
        // Check Rows
        for (let y = 0; y < BOARD_SIZE; y++) {
            if (grid[y].every(val => val === 1)) {
                clearRow(y);
                linesCleared++;
            }
        }
        
        // Check Cols
        for (let x = 0; x < BOARD_SIZE; x++) {
            let colFilled = true;
            for (let y = 0; y < BOARD_SIZE; y++) {
                if (grid[y][x] === 0) {
                    colFilled = false;
                    break;
                }
            }
            if (colFilled) {
                clearCol(x);
                linesCleared++;
            }
        }
        
        if (linesCleared > 0) {
            updateScore(score + (linesCleared * 100) + ((linesCleared-1) * 50));
        }
    }

    function clearRow(y) {
        // Remove from undo history if clearing
        lastPlacement = lastPlacement.filter(p => p.y !== y);
        
        for (let x = 0; x < BOARD_SIZE; x++) {
            if (grid[y][x] === 1) triggerStarExplosion(x, y); 
            grid[y][x] = 0;
            resetCell(x, y);
        }
    }

    function clearCol(x) {
        // Remove from undo history if clearing
        lastPlacement = lastPlacement.filter(p => p.x !== x);
        
        for (let y = 0; y < BOARD_SIZE; y++) {
             if (grid[y][x] === 1) triggerStarExplosion(x, y);
            grid[y][x] = 0;
            resetCell(x, y);
        }
    }

    function triggerStarExplosion(x, y) {
        const cell = document.getElementById(`cell-${x}-${y}`);
        if(!cell) return;
        const rect = cell.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const color = cell.style.backgroundColor || '#fbbf24'; 

        for(let i=0; i<5; i++) {
            createValidStar(centerX, centerY, color);
        }
    }

    function createValidStar(x, y, color) {
        const star = document.createElement('div');
        star.innerHTML = `<svg viewBox="0 0 24 24" fill="${color}" width="100%" height="100%"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>`;
        star.style.position = 'fixed';
        star.style.left = (x - 10) + 'px';
        star.style.top = (y - 10) + 'px';
        star.style.width = '20px';
        star.style.height = '20px';
        star.style.pointerEvents = 'none';
        star.style.zIndex = '10001';
        star.style.transition = 'transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.6s ease-out';
        
        document.body.appendChild(star);
        
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * 60 + 30; 
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        const rot = Math.random() * 360;

        requestAnimationFrame(() => {
            star.style.transform = `translate(${tx}px, ${ty}px) rotate(${rot}deg) scale(0)`;
            star.style.opacity = '0';
        });
        
        setTimeout(() => star.remove(), 600);
    }

    function resetCell(x, y) {
        const cell = document.getElementById(`cell-${x}-${y}`);
        if (cell) {
            cell.style.backgroundColor = '';
            cell.style.boxShadow = '';
            cell.className = 'w-full h-full bg-gray-800 rounded-sm border border-gray-700/50';
        }
    }

    function updateScore(newScore) {
        score = newScore;
        const el = document.getElementById('bp-score');
        if (el) el.textContent = score;
    }

    function checkGameOver() {
        const hand = document.getElementById('bp-hand');
        if (!hand || hand.children.length === 0) return;
        
        const shapes = Array.from(hand.children).map(wrapper => wrapper._shape);
        
        let canMove = false;
        
        for (let s = 0; s < shapes.length; s++) {
            const shape = shapes[s];
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (canPlace(shape, x, y)) {
                        canMove = true;
                        break;
                    }
                }
                if (canMove) break;
            }
            if (canMove) break;
        }
        
        if (!canMove) {
            const go = document.getElementById('bp-game-over');
            const scoreDisplay = document.getElementById('bp-final-score');
            if (go) {
                go.classList.remove('hidden');
                if(scoreDisplay) scoreDisplay.textContent = score;
            }
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', window.initBlockPuzzle);
    } else {
        setTimeout(window.initBlockPuzzle, 100);
    }

})();
</script><script id="script-switcher">
// Game Switcher Logic
document.addEventListener('DOMContentLoaded', () => {
    
    // Helper to hide all
    function hideAllGames() {
        const games = ['flashcard-game', 'climb-game-container', 'mixmatch-container', 'blockpuzzle-container'];
        games.forEach(id => {
            const el = document.getElementById(id);
            if(el) el.style.display = 'none';
        });
    }

    // Helper to close panel robustly
    function closePracticesPanel(linkEl) {
        const menu = linkEl.closest('.Practices-menu');
        if (menu) {
            const panel = menu.querySelector('.Practices-panel');
            if (panel) {
                panel.classList.remove('is-open');
                panel.setAttribute('aria-hidden', 'true');
            }
        }
    }

    // MixMatch Switch
    window.switchToMixMatch = function() {
        hideAllGames();
        const el = document.getElementById('mixmatch-container');
        if(el) {
            el.style.display = 'flex';
            if(window.initMixMatch) window.initMixMatch();
        }
    };

    // BlockPuzzle Switch
    window.switchToBlockPuzzle = function() {
        hideAllGames();
        const el = document.getElementById('blockpuzzle-container');
        if(el) {
            el.style.display = 'flex';
            if(window.initBlockPuzzle) window.initBlockPuzzle();
        }
    };

    // Listeners for Menu Links
    // Note: We use stopImmediatePropagation to prevent conflicts with global delegated listeners in practice_games.js
    document.querySelectorAll('a[href="#mixmatch"]').forEach(el => {
        el.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            window.switchToMixMatch();
            closePracticesPanel(el);
        });
    });

    document.querySelectorAll('a[href="#blockpuzzle"]').forEach(el => {
        el.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            window.switchToBlockPuzzle();
            closePracticesPanel(el);
        });
    });
    
    // Also patch existing Flashcards/Climb listeners to ensure they hide new games
    const oldFlash = window.switchToFlashcards;
    window.switchToFlashcards = function() {
        hideAllGames();
        const el = document.getElementById('flashcard-game');
        if(el) el.style.display = 'flex';
    };

    // Hook into Boost link if it exists and uses a global function?
    // Usually it just toggles display manually in its own listener, so hideAllGames helped.
});
</script></body>
</html>