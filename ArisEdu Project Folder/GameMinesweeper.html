<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper - Arcade</title>    <script src="firebase-utils.js"></script>
    <style>
        #game-session-timer {
            font-size: 2.5rem !important;
            font-weight: 700 !important;
        }
    </style>    <script>
        let timerIntervalId;
        let drainIntervalId;
        
        (async function() {
            await initializeFirebase();
            
            function getUser() {
                return JSON.parse(localStorage.getItem('user') || '{}');
            }
            
            function saveUser(user) {
                localStorage.setItem('user', JSON.stringify(user));
            }

            function showOutOfTokensPopup() {
                clearInterval(timerIntervalId);
                clearInterval(drainIntervalId);
                
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:99999;display:flex;align-items:center;justify-content:center;';
                
                const modal = document.createElement('div');
                modal.style.cssText = 'background:white;border-radius:1rem;padding:2rem;max-width:400px;text-align:center;box-shadow:0 20px 25px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="font-size:3rem;margin-bottom:1rem;">💸</div>
                    <h2 style="font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#1e293b;">Out of Tokens!</h2>
                    <p style="margin-bottom:1.5rem;color:#64748b;">Your token balance hit zero.</p>
                    <p style="margin-bottom:1.5rem;color:#94a3b8;font-size:0.85rem;">Earn more tokens by completing lessons and quizzes!</p>
                    <button id="back-to-arcade" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#f59e0b;color:#000;cursor:pointer;font-weight:700;font-size:1rem;">Back to Arcade</button>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                modal.querySelector('#back-to-arcade').onclick = () => {
                    sessionStorage.removeItem('validGameAccess');
                    window.location.href = 'arcade.html';
                };
            }
            
            window.initializeTokenDrain = function() {
                const sidebar = document.getElementById('game-sidebar');
                if (!sidebar) return;
                
                let timerDisplay = document.getElementById('game-session-timer');
                if (!timerDisplay) {
                    timerDisplay = document.createElement('div');
                    timerDisplay.id = 'game-session-timer';
                    sidebar.appendChild(timerDisplay);
                }

                function updateTimerDisplay() {
                    const user = getUser();
                    const remaining = Math.max(0, user.points || 0);
                    timerDisplay.textContent = remaining + '💎';
                    timerDisplay.className = remaining <= 20 ? 'warning' : '';
                    
                    if (remaining <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                function drainTokens() {
                    const user = getUser();
                    const pts = user.points || 0;
                    if (pts > 0) {
                        user.points = pts - 1;
                        saveUser(user);
                        updateTimerDisplay();
                    } else if (pts <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                if (timerIntervalId) clearInterval(timerIntervalId);
                if (drainIntervalId) clearInterval(drainIntervalId);
                
                updateTimerDisplay();
                drainIntervalId = setInterval(drainTokens, 1000);
                
                // Pause drain when page is hidden
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        clearInterval(drainIntervalId);
                    } else {
                        drainIntervalId = setInterval(drainTokens, 1000);
                    }
                });
            };
            
            document.addEventListener('DOMContentLoaded', window.initializeTokenDrain);
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        body { font-family: 'Orbitron', monospace; padding-top: 50px; }
        canvas { border-radius: 0.5rem; }
        #game {
            width: 100%;
            height: auto;
        }
        #game-wrapper { margin-left: 150px; width: min(720px, calc(100vw - 360px)); max-width: 100%; }
        #game-sidebar {
            background: rgba(55, 65, 81, 0.98); border-radius: 1rem; padding: 1.5rem;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start; width: 400px;
            min-height: 200px;
            border: 2px solid rgba(107, 114, 128, 0.9);
            box-shadow: 0 20px 45px rgba(0,0,0,0.6);
        }
    </style>
    <script src="theme_manager.js"></script>
</head>
<body class="dark-mode bg-gray-900 min-h-screen text-white">
<script src="scripts/taskbar.js"></script>

<!-- Translation Scripts -->
<script src="scripts/global_translations.js?v=8.0"></script>
<script src="scripts/spanish_translations.js?v=1.0"></script>
<script src="scripts/hindi_translations.js?v=1.0"></script>

<div class="flex flex-row items-start justify-start p-4 gap-10 overflow-x-auto overflow-y-visible">
    <div id="game-wrapper" class="relative flex-shrink-0 max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-gray-300 to-gray-500 bg-clip-text text-transparent" data-i18n="MINESWEEPER">MINESWEEPER</h1>
                <p class="text-xs text-gray-400 font-sans" data-i18n="Find all mines without detonating!">Find all mines without detonating!</p>
            </div>
            <div class="flex gap-4 text-right">
                <div>
                    <div class="text-xs text-gray-400 font-sans">⏱ TIME</div>
                    <div id="timer" class="text-2xl font-bold text-cyan-400">0:00</div>
                </div>
                <div>
                    <div class="text-xs text-gray-400 font-sans">MINES</div>
                    <div id="mine-count" class="text-2xl font-bold text-yellow-400">10</div>
                </div>
                <div>
                    <div class="text-xs text-gray-400 font-sans" data-i18n="SCORE">SCORE</div>
                    <div id="score" class="text-2xl font-bold text-white">0</div>
                </div>
            </div>
        </div>

        <div class="flex gap-2 mb-4">
            <button onclick="newGame(9,9,10)" class="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm font-bold transition active:scale-95">😊 Easy</button>
            <button onclick="newGame(16,16,40)" class="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm font-bold transition active:scale-95">😐 Medium</button>
            <button onclick="newGame(16,30,99)" class="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm font-bold transition active:scale-95">😈 Hard</button>
        </div>
        <p id="best-time" class="text-xs text-gray-500 mb-2 font-sans"></p>

        <canvas id="game" class="bg-gray-900 border-2 border-gray-700 mx-auto"></canvas>

        <p class="text-center text-xs text-gray-500 mt-4 font-sans" data-i18n="Click to reveal · Right-click to flag">Click to reveal · Right-click to flag</p>

        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 id="end-title" class="text-3xl font-bold mb-2">GAME OVER</h2>
            <p id="end-msg" class="text-gray-300 mb-6 font-sans"></p>
            <div class="text-4xl font-bold text-white mb-8" id="final-score">0</div>
            <button onclick="newGame()" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95" data-i18n="PLAY AGAIN">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <div id="game-sidebar">
        <div style="width:100%;text-align:center;color:#9ca3af;margin-bottom:1rem;font-size:0.875rem;font-weight:600;">
            ⭐ TOKEN SESSION
        </div>
    </div>
</div>

<script>
    // ===== Canvas-based Minesweeper =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const CELL = 34;       // total cell size including gap
    const GAP = 2;         // gap between cells
    const INNER = CELL - GAP * 2;  // drawable area per cell
    const BOARD_PAD = 4;   // padding around the whole board

    const NUM_COLORS = {
        1: '#3b82f6', 2: '#22c55e', 3: '#ef4444', 4: '#7c3aed',
        5: '#b45309', 6: '#06b6d4', 7: '#475569', 8: '#6b7280'
    };

    let rows = 9, cols = 9, mineCount = 10;
    let board = [], revealed = [], flagged = [];
    let gameActive = true, score = 0, firstClick = true;
    let hoverR = -1, hoverC = -1;
    let timerSeconds = 0, timerInterval = null;
    let bestTimes = JSON.parse(localStorage.getItem('minesweeper_best') || '{}');
    let revealAnim = []; // {r, c, progress} for animated reveal

    function getDiffKey() { return rows + 'x' + cols + 'x' + mineCount; }

    function updateBestDisplay() {
        const key = getDiffKey();
        const best = bestTimes[key];
        const el = document.getElementById('best-time');
        if (best) {
            const m = Math.floor(best / 60), s = best % 60;
            el.textContent = 'Best: ' + m + ':' + (s < 10 ? '0' : '') + s;
        } else {
            el.textContent = '';
        }
    }

    function startTimer() {
        stopTimer();
        timerSeconds = 0;
        document.getElementById('timer').textContent = '0:00';
        timerInterval = setInterval(() => {
            timerSeconds++;
            const m = Math.floor(timerSeconds / 60), s = timerSeconds % 60;
            document.getElementById('timer').textContent = m + ':' + (s < 10 ? '0' : '') + s;
        }, 1000);
    }

    function stopTimer() {
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    }

    // ---- Coordinate conversion ----
    function getCellFromMouse(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mx = (e.clientX - rect.left) * scaleX - BOARD_PAD;
        const my = (e.clientY - rect.top) * scaleY - BOARD_PAD;
        const c = Math.floor(mx / CELL);
        const r = Math.floor(my / CELL);
        if (r >= 0 && r < rows && c >= 0 && c < cols) return { r, c };
        return null;
    }

    // ---- Game logic ----
    function newGame(r, c, m) {
        rows = r || rows;
        cols = c || cols;
        mineCount = m || mineCount;
        board = []; revealed = []; flagged = [];
        gameActive = true; firstClick = true; score = 0;
        hoverR = -1; hoverC = -1;
        revealAnim = [];
        stopTimer();
        timerSeconds = 0;
        document.getElementById('timer').textContent = '0:00';
        document.getElementById('score').textContent = '0';
        document.getElementById('mine-count').textContent = mineCount;
        document.getElementById('game-over').classList.add('hidden');
        updateBestDisplay();

        for (let i = 0; i < rows; i++) {
            board[i] = []; revealed[i] = []; flagged[i] = [];
            for (let j = 0; j < cols; j++) {
                board[i][j] = 0;
                revealed[i][j] = false;
                flagged[i][j] = false;
            }
        }
        // Resize canvas to fit board
        canvas.width = cols * CELL + BOARD_PAD * 2;
        canvas.height = rows * CELL + BOARD_PAD * 2;
        draw();
    }

    function placeMines(safeR, safeC) {
        let placed = 0;
        while (placed < mineCount) {
            const r = Math.floor(Math.random() * rows);
            const c = Math.floor(Math.random() * cols);
            if (board[r][c] !== -1 && !(Math.abs(r - safeR) <= 1 && Math.abs(c - safeC) <= 1)) {
                board[r][c] = -1;
                placed++;
            }
        }
        // Calculate neighbor counts
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (board[i][j] === -1) continue;
                let count = 0;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = i + dr, nc = j + dc;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && board[nr][nc] === -1) count++;
                    }
                }
                board[i][j] = count;
            }
        }
    }

    function floodReveal(startR, startC) {
        const stack = [[startR, startC]];
        while (stack.length > 0) {
            const [r, c] = stack.pop();
            if (r < 0 || r >= rows || c < 0 || c >= cols) continue;
            if (revealed[r][c] || flagged[r][c]) continue;
            revealed[r][c] = true;
            revealAnim.push({ r, c, progress: 0 });
            score += 5;
            if (board[r][c] === 0) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr !== 0 || dc !== 0) stack.push([r + dr, c + dc]);
                    }
                }
            }
        }
    }

    function checkWin() {
        let unrevealed = 0;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (!revealed[i][j]) unrevealed++;
            }
        }
        if (unrevealed === mineCount) {
            score += 100;
            endGame(true);
        }
    }

    function endGame(won) {
        gameActive = false;
        stopTimer();
        // Save best time on win
        if (won) {
            const key = getDiffKey();
            if (!bestTimes[key] || timerSeconds < bestTimes[key]) {
                bestTimes[key] = timerSeconds;
                localStorage.setItem('minesweeper_best', JSON.stringify(bestTimes));
            }
        }
        document.getElementById('score').textContent = score;
        document.getElementById('final-score').textContent = score + (won ? ' (' + document.getElementById('timer').textContent + ')' : '');
        document.getElementById('end-title').textContent = won ? '🎉 YOU WIN!' : '💥 BOOM!';
        document.getElementById('end-title').style.color = won ? '#22c55e' : '#ef4444';
        document.getElementById('end-msg').textContent = won ? 'All mines found!' : 'You hit a mine!';
        document.getElementById('game-over').classList.remove('hidden');
    }

    // ---- Input handling ----
    canvas.addEventListener('click', (e) => {
        if (!gameActive) return;
        const pos = getCellFromMouse(e);
        if (!pos) return;
        const { r, c } = pos;
        if (flagged[r][c]) return;
        if (firstClick) { placeMines(r, c); firstClick = false; startTimer(); }
        if (board[r][c] === -1) {
            revealed[r][c] = true;
            revealAnim.push({ r, c, progress: 0 });
            gameActive = false;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (board[i][j] === -1) {
                        revealed[i][j] = true;
                        revealAnim.push({ r: i, c: j, progress: 0 });
                    }
                }
            }
            draw();
            endGame(false);
            return;
        }
        floodReveal(r, c);
        document.getElementById('score').textContent = score;
        draw();
        checkWin();
    });

    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (!gameActive) return;
        const pos = getCellFromMouse(e);
        if (!pos) return;
        const { r, c } = pos;
        if (revealed[r][c]) return;
        flagged[r][c] = !flagged[r][c];
        const flagCount = flagged.flat().filter(Boolean).length;
        document.getElementById('mine-count').textContent = Math.max(0, mineCount - flagCount);
        draw();
    });

    canvas.addEventListener('mousemove', (e) => {
        const pos = getCellFromMouse(e);
        const newR = pos ? pos.r : -1;
        const newC = pos ? pos.c : -1;
        if (newR !== hoverR || newC !== hoverC) {
            hoverR = newR;
            hoverC = newC;
            draw();
        }
    });

    canvas.addEventListener('mouseleave', () => {
        hoverR = -1; hoverC = -1;
        draw();
    });

    // ---- Canvas drawing ----
    function roundRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    function draw() {
        const W = canvas.width, H = canvas.height;

        // Board background with gradient
        const bgGrad = ctx.createLinearGradient(0, 0, W, H);
        bgGrad.addColorStop(0, '#374151'); bgGrad.addColorStop(1, '#1f2937');
        ctx.fillStyle = bgGrad;
        roundRect(0, 0, W, H, 8);
        ctx.fill();

        // Update reveal animations
        revealAnim = revealAnim.filter(a => { a.progress += 0.12; return a.progress < 1; });

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const x = BOARD_PAD + j * CELL + GAP;
                const y = BOARD_PAD + i * CELL + GAP;

                const anim = revealAnim.find(a => a.r === i && a.c === j);
                const animScale = anim ? Math.min(1, anim.progress * 1.5) : 1;

                if (revealed[i][j]) {
                    if (board[i][j] === -1) {
                        // Mine cell
                        const mGrad = ctx.createLinearGradient(x, y, x+INNER, y+INNER);
                        mGrad.addColorStop(0, '#f87171'); mGrad.addColorStop(1, '#ef4444');
                        ctx.fillStyle = mGrad;
                        roundRect(x, y, INNER, INNER, 4);
                        ctx.fill();
                        ctx.fillStyle = '#1e293b';
                        ctx.beginPath();
                        ctx.arc(x + INNER / 2, y + INNER / 2, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#1e293b';
                        ctx.lineWidth = 2;
                        const cx = x + INNER / 2, cy = y + INNER / 2;
                        for (let a = 0; a < 4; a++) {
                            const angle = (a * Math.PI) / 4;
                            ctx.beginPath();
                            ctx.moveTo(cx + Math.cos(angle) * 5, cy + Math.sin(angle) * 5);
                            ctx.lineTo(cx + Math.cos(angle) * 11, cy + Math.sin(angle) * 11);
                            ctx.stroke();
                        }
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.beginPath();
                        ctx.arc(cx - 3, cy - 3, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Revealed cell with depth
                        ctx.save();
                        if (anim) {
                            ctx.translate(x + INNER/2, y + INNER/2);
                            ctx.scale(animScale, animScale);
                            ctx.translate(-(x + INNER/2), -(y + INNER/2));
                        }
                        const revGrad = ctx.createLinearGradient(x, y, x, y+INNER);
                        revGrad.addColorStop(0, '#111827'); revGrad.addColorStop(1, '#0f172a');
                        ctx.fillStyle = revGrad;
                        roundRect(x, y, INNER, INNER, 4);
                        ctx.fill();

                        if (board[i][j] > 0) {
                            const numColor = NUM_COLORS[board[i][j]] || '#e2e8f0';
                            ctx.shadowColor = numColor;
                            ctx.shadowBlur = 4;
                            ctx.fillStyle = numColor;
                            ctx.font = 'bold 16px Orbitron, monospace';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(board[i][j], x + INNER / 2, y + INNER / 2 + 1);
                            ctx.shadowBlur = 0;
                        }
                        ctx.restore();
                    }
                } else if (flagged[i][j]) {
                    const fGrad = ctx.createLinearGradient(x, y, x+INNER, y+INNER);
                    fGrad.addColorStop(0, '#f59e0b'); fGrad.addColorStop(1, '#d97706');
                    ctx.fillStyle = fGrad;
                    roundRect(x, y, INNER, INNER, 4);
                    ctx.fill();
                    ctx.strokeStyle = '#1e293b';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + INNER / 2, y + 6);
                    ctx.lineTo(x + INNER / 2, y + INNER - 6);
                    ctx.stroke();
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath();
                    ctx.moveTo(x + INNER / 2, y + 6);
                    ctx.lineTo(x + INNER / 2 + 9, y + 12);
                    ctx.lineTo(x + INNER / 2, y + 18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#1e293b';
                    ctx.fillRect(x + INNER / 2 - 5, y + INNER - 8, 10, 2);
                } else {
                    // Hidden cell with 3D bevel
                    const isHover = (i === hoverR && j === hoverC && gameActive);
                    const cellGrad = ctx.createLinearGradient(x, y, x, y + INNER);
                    if (isHover) {
                        cellGrad.addColorStop(0, '#a1b0c4'); cellGrad.addColorStop(1, '#7e8ea0');
                    } else {
                        cellGrad.addColorStop(0, '#6b7a8d'); cellGrad.addColorStop(1, '#556270');
                    }
                    ctx.fillStyle = cellGrad;
                    roundRect(x, y, INNER, INNER, 4);
                    ctx.fill();
                    // Top bevel highlight
                    ctx.fillStyle = isHover ? 'rgba(255,255,255,0.22)' : 'rgba(255,255,255,0.1)';
                    ctx.fillRect(x + 2, y + 2, INNER - 4, 3);
                    ctx.fillStyle = 'rgba(255,255,255,0.06)';
                    ctx.fillRect(x + 2, y + 5, 3, INNER - 10);
                    // Bottom shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.12)';
                    ctx.fillRect(x + 2, y + INNER - 4, INNER - 4, 2);
                }
            }
        }
        
        if (revealAnim.length > 0) {
            requestAnimationFrame(draw);
        }
    }

    // ---- Start default game ----
    newGame(9, 9, 10);

</script>
</body>
</html>

