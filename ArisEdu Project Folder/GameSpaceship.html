<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter - Arcade</title>    <script src="firebase-utils.js"></script>
    <style>
        #game-session-timer {
            font-size: 2.5rem !important;
            font-weight: 700 !important;
        }
    </style>    <script>
        let timerIntervalId;
        let drainIntervalId;
        
        (async function() {
            await initializeFirebase();
            
            if (sessionStorage.getItem('validGameAccess') !== 'true') {
                alert('You must access this game from the Arcade page.');
                window.location.href = 'arcade.html';
                return;
            }

            function showOutOfTokensPopup() {
                clearInterval(timerIntervalId);
                clearInterval(drainIntervalId);
                
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:99999;display:flex;align-items:center;justify-content:center;';
                
                const modal = document.createElement('div');
                modal.style.cssText = 'background:white;border-radius:1rem;padding:2rem;max-width:400px;text-align:center;box-shadow:0 20px 25px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="font-size:3rem;margin-bottom:1rem;">💸</div>
                    <h2 style="font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#1e293b;">Out of Tokens!</h2>
                    <p style="margin-bottom:1.5rem;color:#64748b;">Your token balance hit zero.</p>
                    <p style="margin-bottom:1.5rem;color:#94a3b8;font-size:0.85rem;">Earn more tokens by completing lessons and quizzes!</p>
                    <button id="back-to-arcade" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#f59e0b;color:#000;cursor:pointer;font-weight:700;font-size:1rem;">Back to Arcade</button>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                modal.querySelector('#back-to-arcade').onclick = () => {
                    sessionStorage.removeItem('validGameAccess');
                    window.location.href = 'arcade.html';
                };
            }
            
            window.initializeTokenDrain = function() {
                const sidebar = document.getElementById('game-sidebar');
                if (!sidebar) return;
                
                let timerDisplay = document.getElementById('game-session-timer');
                if (!timerDisplay) {
                    timerDisplay = document.createElement('div');
                    timerDisplay.id = 'game-session-timer';
                    sidebar.appendChild(timerDisplay);
                }

                function updateTimerDisplay() {
                    const user = JSON.parse(localStorage.getItem('user') || '{}');
                    const remaining = Math.max(0, user.points || 0);
                    timerDisplay.textContent = remaining + '💎';
                    timerDisplay.className = remaining <= 20 ? 'warning' : '';
                    
                    if (remaining <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                function drainTokens() {
                    const user = JSON.parse(localStorage.getItem('user') || '{}');
                    const pts = user.points || 0;
                    if (pts > 0) {
                        user.points = pts - 1;
                        localStorage.setItem('user', JSON.stringify(user));
                        updateTimerDisplay();
                    } else if (pts <= 0) {
                        showOutOfTokensPopup();
                    }
                }
                
                if (timerIntervalId) clearInterval(timerIntervalId);
                if (drainIntervalId) clearInterval(drainIntervalId);
                
                updateTimerDisplay();
                drainIntervalId = setInterval(drainTokens, 1000);
                
                // Pause drain when page is hidden
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        clearInterval(drainIntervalId);
                    } else {
                        drainIntervalId = setInterval(drainTokens, 1000);
                    }
                });
            };
            
            document.addEventListener('DOMContentLoaded', window.initializeTokenDrain);
        })();
    </script>
            
            if (sessionStorage.getItem('validGameAccess') !== 'true') {
                alert('You must access this game from the Arcade page.');
                window.location.href = 'arcade.html';
                return;
            }
            
            const expireTime = parseInt(sessionStorage.getItem('gameUnlockExpire')) || 0;
            const now = Math.floor(Date.now() / 1000);

            function checkExpiration() {
                const now = Math.floor(Date.now() / 1000);
                if (now >= gameUnlockExpire) {
                    showExpiredPopup();
                }
            }

            function getUser() {
                return JSON.parse(localStorage.getItem('user') || '{}');
            }

            function canAfford(cost) {
                const user = getUser();
                return (user.points || 0) >= cost;
            }

            function extendSession(cost, duration) {
                const user = getUser();
                if ((user.points || 0) < cost) {
                    return false;
                }

                user.points = (user.points || 0) - cost;
                localStorage.setItem('user', JSON.stringify(user));

                const base = Math.max(gameUnlockExpire || expireTime, Math.floor(Date.now() / 1000));
                gameUnlockExpire = base + duration;
                sessionStorage.setItem('gameUnlockExpire', gameUnlockExpire);

                if (timeoutId) clearTimeout(timeoutId);
                if (timerIntervalId) clearInterval(timerIntervalId);

                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    window.initializeTimer();
                } else {
                    document.addEventListener('DOMContentLoaded', window.initializeTimer, { once: true });
                }

                const now = Math.floor(Date.now() / 1000);
                timeoutId = setTimeout(checkExpiration, Math.max(0, gameUnlockExpire - now) * 1000);
                return true;
            }
            
            function showExpiredPopup() {
                clearInterval(timerIntervalId);
                const canExtend = canAfford(EXTEND_COST);
                
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:99999;display:flex;align-items:center;justify-content:center;';
                
                const modal = document.createElement('div');
                modal.style.cssText = 'background:white;border-radius:1rem;padding:2rem;max-width:400px;text-align:center;box-shadow:0 20px 25px rgba(0,0,0,0.3);';
                
                modal.innerHTML = `
                    <div style="font-size:3rem;margin-bottom:1rem;">⏱️</div>
                    <h2 style="font-size:1.5rem;font-weight:700;margin-bottom:1rem;color:#1e293b;">Session Expired!</h2>
                    <p style="margin-bottom:1.5rem;color:#64748b;">Your access time has run out.</p>
                    <div style="display:flex;gap:1rem;justify-content:center;">
                        <button id="back-to-arcade" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:1px solid #cbd5e1;background:white;color:#64748b;cursor:pointer;font-weight:600;">Back to Arcade</button>
                        ${canExtend ? 
                            `<button id="extend-session" style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#f59e0b;color:#000;cursor:pointer;font-weight:600;">Extend +${EXTEND_DURATION}s (${EXTEND_COST}💎)</button>` :
                            `<button disabled style="padding:0.75rem 1.5rem;border-radius:0.5rem;border:none;background:#e2e8f0;color:#94a3b8;cursor:not-allowed;font-weight:600;">Need ${EXTEND_COST} Tokens</button>`
                        }
                    </div>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                modal.querySelector('#back-to-arcade').onclick = () => {
                    window.location.href = 'arcade.html';
                };
                
                if (canExtend) {
                    modal.querySelector('#extend-session').onclick = () => {
                        if (extendSession(EXTEND_COST, EXTEND_DURATION)) {
                            overlay.remove();
                        }
                    };
                }
            }
            
            if (expireTime <= 0 || expireTime < now) {
                showExpiredPopup();
                return;
            }
            
            sessionStorage.removeItem('validGameAccess');
            gameUnlockExpire = expireTime;
            
            window.initializeTimer = function() {
                const sidebar = document.getElementById('game-sidebar');
                if (!sidebar) return;
                
                let timerDisplay = document.getElementById('game-session-timer');
                if (!timerDisplay) {
                    timerDisplay = document.createElement('div');
                    timerDisplay.id = 'game-session-timer';
                    sidebar.appendChild(timerDisplay);
                }

                // Create token-based extend buttons under the timer (once)
                let controls = document.getElementById('game-session-controls');
                if (!controls) {
                    controls = document.createElement('div');
                    controls.id = 'game-session-controls';
                    controls.style.cssText = 'margin-top:0.75rem;display:flex;flex-direction:column;gap:0.5rem;width:100%;';

                    EXTEND_OPTIONS.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.textContent = `+${opt.duration}s (${opt.cost}💎)`;
                        btn.style.cssText = 'width:100%;padding:0.5rem 0.75rem;border-radius:0.5rem;border:none;background:#2563eb;color:white;font-weight:600;font-size:0.9rem;cursor:pointer;';
                        btn.onclick = () => {
                            if (!extendSession(opt.cost, opt.duration)) {
                                alert('Not enough tokens to add time.');
                            }
                        };
                        controls.appendChild(btn);
                    });

                    sidebar.appendChild(controls);
                }

                function updateTimerDisplay() {
                    const now = Math.floor(Date.now() / 1000);
                    const remaining = Math.max(0, gameUnlockExpire - now);
                    timerDisplay.textContent = remaining + 's';
                    timerDisplay.className = remaining <= 20 ? 'warning' : '';
                    
                    if (remaining <= 0) {
                        clearInterval(timerIntervalId);
                        showExpiredPopup();
                    }
                }
                
                if (timerIntervalId) clearInterval(timerIntervalId);
                updateTimerDisplay();
                timerIntervalId = setInterval(updateTimerDisplay, 1000);
            };
            
            // Initialize timer after DOM loads
            document.addEventListener('DOMContentLoaded', window.initializeTimer);
            
            // Set up timeout for expiration
            timeoutId = setTimeout(checkExpiration, (expireTime - now) * 1000);
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        #game-sidebar {
            background: rgba(55, 65, 81, 0.98);
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 400px;
            min-height: 800px;
            border: 2px solid rgba(107, 114, 128, 0.9);
            box-shadow: 0 20px 45px rgba(0,0,0,0.6);
        }
        #game-session-timer {
            background: rgba(34, 197, 94, 0.95);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            font-size: 2rem;
            font-family: monospace;
            width: 100%;
            text-align: center;
            margin-top: 0.5rem;
            letter-spacing: 2px;
        }
        #game-session-timer.warning {
            background: rgba(239, 68, 68, 0.95);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        body { font-family: 'Orbitron', monospace; padding-top: 50px; }
        canvas { border-radius: 0.5rem; }
        #game-wrapper {
            margin-left:150px;
            width: min(720px, calc(100vw - 360px));
            max-width: 100%;
        }
        .pause-btn { position: absolute; bottom: 0.75rem; left: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .pause-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        :fullscreen { background: #111827; }
        
    </style>
    <script src="theme_manager.js"></script>
</head>
<body class="dark-mode bg-gray-900 min-h-screen text-white">
<script src="scripts/taskbar.js"></script>

<!-- Translation Scripts -->
<script src="scripts/global_translations.js?v=8.0"></script>
<script src="scripts/spanish_translations.js?v=1.0"></script>
<script src="scripts/hindi_translations.js?v=1.0"></script>

    <div class="flex flex-row items-start justify-start p-4 gap-10 overflow-x-auto overflow-y-visible">

    <div id="game-wrapper" class="relative flex-shrink-0 max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
        <button class="pause-btn" onclick="togglePause()" title="Pause"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-purple-400 to-violet-600 bg-clip-text text-transparent">SPACE SHOOTER</h1>
                <p class="text-xs text-gray-400 font-sans">Survive the waves!</p>
            </div>
            <div class="flex gap-4 text-right">
                <div>
                    <div class="text-xs text-gray-400 font-sans">WAVE</div>
                    <div id="wave" class="text-2xl font-bold text-white">1</div>
                </div>
                <div>
                    <div class="text-xs text-gray-400 font-sans" data-i18n="SCORE">SCORE</div>
                    <div id="score" class="text-2xl font-bold text-white">0</div>
                </div>
            </div>
        </div>

        <canvas id="game" class="bg-gray-950 border-2 border-gray-700 mx-auto block" width="360" height="480"></canvas>
        <p class="text-center text-xs text-gray-500 mt-4 font-sans">Arrow keys / WASD to move. Space to shoot.</p>

        <!-- Game Over -->
        <div id="game-over" class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-red-500 font-bold mb-2">DESTROYED</h2>
            <p class="text-gray-300 mb-2 font-sans">Your ship was destroyed!</p>
            <div class="text-4xl font-bold text-white mb-8" id="final-score">0</div>
            <button onclick="resetGame()" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                <span data-i18n="TRY AGAIN">TRY AGAIN</span>
            </button>
        </div>

        <!-- Start -->
        <div id="start-screen" class="absolute inset-0 bg-black/80 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-purple-400 font-bold mb-2">🚀 SPACE SHOOTER</h2>
            <p class="text-gray-300 mb-4 font-sans">Dodge asteroids, blast enemies,<br>survive as long as you can!</p>
            <p class="text-sm text-gray-400 mb-6 font-sans">WASD/Arrows to Move | Space to Shoot</p>
            <button onclick="startGame()" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                LAUNCH
            </button>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-30 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-4xl text-white font-bold mb-2">PAUSED</h2>
            <p class="text-gray-400 mb-4 font-sans">Game is paused</p>
            <p class="text-sm text-gray-500 mb-6 font-sans">WASD/Arrows to Move | Space to Shoot</p>
            <button onclick="togglePause()" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                <span data-i18n="RESUME">RESUME</span>
            </button>
        </div>

    <div id="game-sidebar">
        <div style="width: 100%; text-align: center; color: #9ca3af; margin-bottom: 1rem; font-size: 0.875rem; font-weight: 600;">
            SESSION
        </div>
    </div>

    </div>

    <script>
        let gamePaused = false;
        function togglePause() {
            if (!running && !gamePaused) return;
            gamePaused = !gamePaused;
            document.getElementById('pause-screen').classList.toggle('hidden', !gamePaused);
            if (gamePaused) { running = false; cancelAnimationFrame(animFrame); Object.keys(keys).forEach(k => keys[k] = false); }
            else { running = true; gameLoop(); }
        }

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        const keys = {};
        let ship, bullets, enemies, asteroids, particles, stars;
        let score, wave, spawnTimer, waveTimer, running, animFrame;
        let lives, invincible, invincibleTimer, waveFlash = 0;
        const SHIP_W = 24, SHIP_H = 30;
        const BULLET_SPEED = 7;
        const ENEMY_SPEED_BASE = 1.5;

        function init() {
            ship = {x: W/2 - SHIP_W/2, y: H - 60, w: SHIP_W, h: SHIP_H};
            bullets = [];
            enemies = [];
            asteroids = [];
            particles = [];
            score = 0;
            wave = 1;
            lives = 3;
            invincible = false;
            invincibleTimer = 0;
            spawnTimer = 0;
            waveTimer = 0;
            // Stars background
            stars = Array.from({length: 80}, () => ({
                x: Math.random() * W,
                y: Math.random() * H,
                s: Math.random() * 1.5 + 0.5,
                speed: Math.random() * 0.5 + 0.3
            }));
            document.getElementById('score').textContent = '0';
            document.getElementById('wave').textContent = '1';
        }

        function spawnEnemy() {
            const type = Math.random() < 0.3 ? 'fast' : 'normal';
            enemies.push({
                x: Math.random() * (W - 20) + 10,
                y: -20,
                w: type === 'fast' ? 16 : 22,
                h: type === 'fast' ? 16 : 22,
                speed: type === 'fast' ? ENEMY_SPEED_BASE + wave * 0.3 + 1 : ENEMY_SPEED_BASE + wave * 0.2,
                type,
                hp: type === 'fast' ? 1 : 2,
                shootTimer: Math.random() * 60 + 30
            });
        }

        function spawnAsteroid() {
            const size = Math.random() * 15 + 10;
            asteroids.push({
                x: Math.random() * (W - size),
                y: -size,
                r: size,
                speed: Math.random() * 1.5 + 0.8,
                rotation: 0,
                rotSpeed: (Math.random() - 0.5) * 0.05
            });
        }

        function addParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.3;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 25 + Math.random() * 20,
                    color,
                    r: Math.random() * 4 + 1.5
                });
            }
        }

        let screenShake = 0;
        function triggerShake(intensity) { screenShake = intensity; }

        let shootCooldown = 0;

        function update() {
            // Ship movement
            const speed = 5;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) ship.x -= speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) ship.x += speed;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) ship.y -= speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) ship.y += speed;
            ship.x = Math.max(0, Math.min(W - ship.w, ship.x));
            ship.y = Math.max(0, Math.min(H - ship.h, ship.y));

            // Shooting
            shootCooldown--;
            if (keys[' '] && shootCooldown <= 0) {
                bullets.push({x: ship.x + ship.w/2 - 2, y: ship.y - 5, w: 4, h: 10, friendly: true});
                shootCooldown = 10;
            }

            // Move bullets
            bullets.forEach(b => { b.y += b.friendly ? -BULLET_SPEED : 4; });
            bullets = bullets.filter(b => b.y > -20 && b.y < H + 20);

            // Stars
            stars.forEach(s => {
                s.y += s.speed;
                if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
            });

            // Spawn enemies
            spawnTimer++;
            const spawnRate = Math.max(30, 80 - wave * 5);
            if (spawnTimer >= spawnRate) {
                spawnTimer = 0;
                spawnEnemy();
                if (Math.random() < 0.3) spawnAsteroid();
            }

            // Wave advancement
            waveTimer++;
            if (waveTimer >= 600) {
                waveTimer = 0;
                wave++;
                waveFlash = 60;
                document.getElementById('wave').textContent = wave;
            }

            // Move enemies
            enemies.forEach(e => {
                e.y += e.speed;
                // Enemy shoots
                e.shootTimer--;
                if (e.shootTimer <= 0 && e.type === 'normal') {
                    bullets.push({x: e.x + e.w/2 - 2, y: e.y + e.h, w: 4, h: 8, friendly: false});
                    e.shootTimer = 60 + Math.random() * 40;
                }
            });
            enemies = enemies.filter(e => e.y < H + 30);

            // Move asteroids
            asteroids.forEach(a => {
                a.y += a.speed;
                a.rotation += a.rotSpeed;
            });
            asteroids = asteroids.filter(a => a.y < H + 40);

            // Particles
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
            });
            particles = particles.filter(p => p.life > 0);

            // Invincibility
            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) invincible = false;
            }

            // Bullet-enemy collision
            bullets.forEach(b => {
                if (!b.friendly) return;
                enemies.forEach((e, ei) => {
                    if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
                        e.hp--;
                        b.y = -999; // remove bullet
                        if (e.hp <= 0) {
                            score += e.type === 'fast' ? 20 : 30;
                            addParticles(e.x + e.w/2, e.y + e.h/2, e.type === 'fast' ? '#f97316' : '#ef4444', 12);
                            triggerShake(3);
                            enemies.splice(ei, 1);
                        }
                    }
                });
                // Bullet-asteroid
                asteroids.forEach((a, ai) => {
                    const dx = (b.x + b.w/2) - a.x;
                    const dy = (b.y + b.h/2) - a.y;
                    if (Math.sqrt(dx*dx + dy*dy) < a.r) {
                        b.y = -999;
                        score += 10;
                        addParticles(a.x, a.y, '#94a3b8', 10);
                        triggerShake(2);
                        asteroids.splice(ai, 1);
                    }
                });
            });

            document.getElementById('score').textContent = score;

            if (invincible) return;

            // Ship-enemy collision
            enemies.forEach((e, ei) => {
                if (ship.x < e.x + e.w && ship.x + ship.w > e.x && ship.y < e.y + e.h && ship.y + ship.h > e.y) {
                    loseLife();
                    enemies.splice(ei, 1);
                }
            });

            // Ship-asteroid collision
            asteroids.forEach((a, ai) => {
                const dx = (ship.x + ship.w/2) - a.x;
                const dy = (ship.y + ship.h/2) - a.y;
                if (Math.sqrt(dx*dx + dy*dy) < a.r + 10) {
                    loseLife();
                    asteroids.splice(ai, 1);
                }
            });

            // Ship-enemy bullet collision
            bullets.forEach((b, bi) => {
                if (b.friendly) return;
                if (b.x < ship.x + ship.w && b.x + b.w > ship.x && b.y < ship.y + ship.h && b.y + b.h > ship.y) {
                    loseLife();
                    bullets.splice(bi, 1);
                }
            });
        }

        function loseLife() {
            lives--;
            addParticles(ship.x + ship.w/2, ship.y + ship.h/2, '#8b5cf6', 16);
            triggerShake(4);
            invincible = true;
            invincibleTimer = 90;
            if (lives <= 0) {
                running = false;
                cancelAnimationFrame(animFrame);
                document.getElementById('final-score').textContent = score;
                document.getElementById('game-over').classList.remove('hidden');
            }
        }

        function draw() {
            // Screen shake
            const shake = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            ctx.save();
            ctx.translate(shake, shake);
            screenShake *= 0.85;

            // Space background with gradient
            const bg = ctx.createLinearGradient(0, 0, 0, H);
            bg.addColorStop(0, '#030712'); bg.addColorStop(0.5, '#0a0f1e'); bg.addColorStop(1, '#030712');
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, W, H);

            // Stars with twinkle and parallax
            stars.forEach(s => {
                const twinkle = 0.3 + Math.sin(Date.now() / 500 + s.x * 10) * 0.2;
                const parallaxShift = screenShake * 0.3;
                ctx.fillStyle = `rgba(255,255,255,${Math.min(1, s.s / 2 + twinkle)})`;
                ctx.beginPath(); ctx.arc(s.x + parallaxShift, s.y, s.s * 0.6, 0, Math.PI * 2); ctx.fill();
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Ship
            if (!invincible || Math.floor(Date.now() / 80) % 2) {
                const cx = ship.x + ship.w/2, sy = ship.y;
                // Ship glow
                const sg = ctx.createRadialGradient(cx, sy + ship.h/2, 0, cx, sy + ship.h/2, ship.w);
                sg.addColorStop(0, 'rgba(139,92,246,0.15)'); sg.addColorStop(1, 'transparent');
                ctx.fillStyle = sg;
                ctx.fillRect(cx - ship.w, sy - 5, ship.w*2, ship.h + 10);

                // Body with gradient
                const shipGrad = ctx.createLinearGradient(cx - ship.w/2, sy, cx + ship.w/2, sy + ship.h);
                shipGrad.addColorStop(0, '#a78bfa'); shipGrad.addColorStop(1, '#7c3aed');
                ctx.fillStyle = shipGrad;
                ctx.beginPath();
                ctx.moveTo(cx, sy);
                ctx.lineTo(cx - ship.w/2, sy + ship.h);
                ctx.lineTo(cx - ship.w/4, sy + ship.h * 0.7);
                ctx.lineTo(cx + ship.w/4, sy + ship.h * 0.7);
                ctx.lineTo(cx + ship.w/2, sy + ship.h);
                ctx.closePath();
                ctx.fill();
                // Wing details
                ctx.strokeStyle = 'rgba(196,181,253,0.4)'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx, sy+5); ctx.lineTo(cx-ship.w/3, sy+ship.h-4); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, sy+5); ctx.lineTo(cx+ship.w/3, sy+ship.h-4); ctx.stroke();
                // Cockpit
                const cockpitGrad = ctx.createRadialGradient(cx, sy+12, 0, cx, sy+12, 5);
                cockpitGrad.addColorStop(0, '#e0d5ff'); cockpitGrad.addColorStop(1, '#c4b5fd');
                ctx.fillStyle = cockpitGrad;
                ctx.beginPath(); ctx.arc(cx, sy + 12, 4, 0, Math.PI * 2); ctx.fill();
                // Flame with multiple layers
                const flicker = Math.random() * 5;
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath(); ctx.moveTo(cx-5, sy+ship.h); ctx.lineTo(cx, sy+ship.h+10+flicker); ctx.lineTo(cx+5, sy+ship.h); ctx.fill();
                ctx.fillStyle = '#f97316';
                ctx.beginPath(); ctx.moveTo(cx-3, sy+ship.h); ctx.lineTo(cx, sy+ship.h+6+flicker*0.7); ctx.lineTo(cx+3, sy+ship.h); ctx.fill();
                ctx.fillStyle = '#fef3c7';
                ctx.beginPath(); ctx.moveTo(cx-1.5, sy+ship.h); ctx.lineTo(cx, sy+ship.h+3+flicker*0.4); ctx.lineTo(cx+1.5, sy+ship.h); ctx.fill();
            }

            // Lives indicator
            for (let i = 0; i < lives; i++) {
                ctx.fillStyle = '#8b5cf6';
                ctx.beginPath();
                ctx.moveTo(15 + i * 20, H - 15);
                ctx.lineTo(10 + i * 20, H - 5);
                ctx.lineTo(20 + i * 20, H - 5);
                ctx.fill();
            }

            // Enemies with improved look
            enemies.forEach(e => {
                if (e.type === 'fast') {
                    // Fast enemy with glow
                    ctx.fillStyle = 'rgba(249,115,22,0.15)';
                    ctx.beginPath(); ctx.arc(e.x+e.w/2, e.y+e.h/2, e.w, 0, Math.PI*2); ctx.fill();
                    const eGrad = ctx.createLinearGradient(e.x, e.y, e.x+e.w, e.y+e.h);
                    eGrad.addColorStop(0, '#fb923c'); eGrad.addColorStop(1, '#ea580c');
                    ctx.fillStyle = eGrad;
                    ctx.beginPath();
                    ctx.moveTo(e.x + e.w/2, e.y + e.h);
                    ctx.lineTo(e.x, e.y);
                    ctx.lineTo(e.x + e.w, e.y);
                    ctx.fill();
                } else {
                    // Normal enemy with detail
                    ctx.fillStyle = 'rgba(239,68,68,0.1)';
                    ctx.beginPath(); ctx.arc(e.x+e.w/2, e.y+e.h/2, e.w, 0, Math.PI*2); ctx.fill();
                    const eGrad = ctx.createLinearGradient(e.x, e.y, e.x, e.y+e.h);
                    eGrad.addColorStop(0, '#f87171'); eGrad.addColorStop(1, '#dc2626');
                    ctx.fillStyle = eGrad;
                    ctx.beginPath(); ctx.roundRect(e.x, e.y, e.w, e.h, 4); ctx.fill();
                    // Window
                    ctx.fillStyle = '#fca5a5';
                    ctx.beginPath(); ctx.arc(e.x + e.w/2, e.y + e.h/2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.beginPath(); ctx.arc(e.x + e.w/2 - 1, e.y + e.h/2 - 1, 1.5, 0, Math.PI * 2); ctx.fill();
                }
            });

            // Asteroids with craters
            asteroids.forEach(a => {
                ctx.save();
                ctx.translate(a.x, a.y);
                ctx.rotate(a.rotation);
                // Asteroid glow
                const aGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r*1.3);
                aGlow.addColorStop(0, 'rgba(100,116,139,0.1)'); aGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = aGlow;
                ctx.beginPath(); ctx.arc(0, 0, a.r*1.3, 0, Math.PI*2); ctx.fill();
                // Main body
                const aGrad = ctx.createRadialGradient(-a.r/4, -a.r/4, 0, 0, 0, a.r);
                aGrad.addColorStop(0, '#94a3b8'); aGrad.addColorStop(1, '#475569');
                ctx.fillStyle = aGrad;
                ctx.beginPath(); ctx.arc(0, 0, a.r, 0, Math.PI * 2); ctx.fill();
                // Craters
                ctx.fillStyle = '#374151';
                ctx.beginPath(); ctx.arc(-a.r/3, -a.r/4, a.r/4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(a.r/4, a.r/5, a.r/5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

            // Bullets with trails
            bullets.forEach(b => {
                if (b.friendly) {
                    // Trail
                    const bGrad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h + 6);
                    bGrad.addColorStop(0, '#a78bfa'); bGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = bGrad;
                    ctx.fillRect(b.x - 1, b.y, b.w + 2, b.h + 8);
                    ctx.fillStyle = '#c4b5fd';
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                } else {
                    ctx.fillStyle = '#fca5a5';
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                    ctx.fillStyle = 'rgba(252,165,165,0.3)';
                    ctx.fillRect(b.x - 1, b.y - 2, b.w + 2, b.h + 4);
                }
            });
            ctx.restore();

            // Wave transition flash
            if (waveFlash > 0) {
                waveFlash--;
                const flashAlpha = Math.min(1, waveFlash / 10 + Math.min(1, (60 - waveFlash) / 20));
                ctx.globalAlpha = flashAlpha * 0.8;
                ctx.fillStyle = '#7c3aed';
                ctx.fillRect(0, 0, W, H);
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 48px Orbitron';
                ctx.textAlign = 'center';
                ctx.globalAlpha = flashAlpha;
                ctx.fillText(`WAVE ${wave}`, W/2, H/2);
                ctx.globalAlpha = 1;
            }
        }

        function gameLoop() {
            if (!running) return;
            update();
            draw();
            animFrame = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            init();
            running = true;
            gameLoop();
        }

        function resetGame() {
            document.getElementById('game-over').classList.add('hidden');
            init();
            running = true;
            gameLoop();
        }

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { togglePause(); e.preventDefault(); return; }
            if (gamePaused) return;
            keys[e.key] = true;
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        // Auto-pause game (and stop timer updates) when tab loses visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (!gamePaused && running && typeof togglePause === 'function') {
                    togglePause();
                }
                if (timerIntervalId) {
                    clearInterval(timerIntervalId);
                    timerIntervalId = null;
                }
            } else {
                if (!timerIntervalId && typeof window.initializeTimer === 'function') {
                    window.initializeTimer();
                }
            }
        });

        // Mobile: touch to move ship toward finger, tap to shoot
        let mobileShoot = null;
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const tx = (e.touches[0].clientX - rect.left) * (W / rect.width);
            const ty = (e.touches[0].clientY - rect.top) * (H / rect.height);
            ship.x = tx - ship.w/2;
            ship.y = ty - ship.h/2;
            keys[' '] = true;
            mobileShoot = setInterval(() => { keys[' '] = true; }, 150);
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const tx = (e.touches[0].clientX - rect.left) * (W / rect.width);
            const ty = (e.touches[0].clientY - rect.top) * (H / rect.height);
            ship.x = tx - ship.w/2;
            ship.y = ty - ship.h/2;
        }, {passive: false});
        canvas.addEventListener('touchend', () => {
            keys[' '] = false;
            if (mobileShoot) { clearInterval(mobileShoot); mobileShoot = null; }
        });

        init();
    </script>
</body>
</html>

