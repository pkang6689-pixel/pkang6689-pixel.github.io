<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter - Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        body { font-family: 'Orbitron', monospace; padding-top: 50px; }
        canvas { border-radius: 0.5rem; }
        .fs-btn { position: absolute; bottom: 0.75rem; right: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .fs-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        .pause-btn { position: absolute; bottom: 0.75rem; left: 0.75rem; z-index: 50; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.75rem; color: white; cursor: pointer; padding: 8px; line-height: 0; transition: background 0.2s, transform 0.2s; }
        .pause-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.1); }
        :fullscreen { background: #111827; }
        :fullscreen body { padding-top: 0 !important; }
    </style>
    <script src="theme_manager.js"></script>
</head>
<body class="dark-mode bg-gray-900 min-h-screen text-white flex flex-col items-center justify-center p-4 overflow-hidden">
<script src="scripts/taskbar.js"></script>

    <div id="game-wrapper" class="relative w-full max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 border border-gray-700">
        <button class="fs-btn" onclick="toggleFS()" title="Fullscreen"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
        <button class="pause-btn" onclick="togglePause()" title="Pause"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-purple-400 to-violet-600 bg-clip-text text-transparent">SPACE SHOOTER</h1>
                <p class="text-xs text-gray-400 font-sans">Survive the waves!</p>
            </div>
            <div class="flex gap-4 text-right">
                <div>
                    <div class="text-xs text-gray-400 font-sans">WAVE</div>
                    <div id="wave" class="text-2xl font-bold text-white">1</div>
                </div>
                <div>
                    <div class="text-xs text-gray-400 font-sans">SCORE</div>
                    <div id="score" class="text-2xl font-bold text-white">0</div>
                </div>
            </div>
        </div>

        <canvas id="game" class="bg-gray-950 border-2 border-gray-700 mx-auto block" width="360" height="480"></canvas>
        <p class="text-center text-xs text-gray-500 mt-4 font-sans">Arrow keys / WASD to move. Space to shoot.</p>

        <!-- Game Over -->
        <div id="game-over" class="hidden absolute inset-0 bg-black/90 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-red-500 font-bold mb-2">DESTROYED</h2>
            <p class="text-gray-300 mb-2 font-sans">Your ship was destroyed!</p>
            <div class="text-4xl font-bold text-white mb-8" id="final-score">0</div>
            <button onclick="resetGame()" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                TRY AGAIN
            </button>
        </div>

        <!-- Start -->
        <div id="start-screen" class="absolute inset-0 bg-black/80 rounded-2xl z-20 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-3xl text-purple-400 font-bold mb-4">ðŸš€ SPACE SHOOTER</h2>
            <p class="text-gray-300 mb-6 font-sans">Dodge asteroids, blast enemies,<br>survive as long as you can!</p>
            <button onclick="startGame()" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                LAUNCH
            </button>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-screen" class="hidden absolute inset-0 bg-black/80 rounded-2xl z-30 flex flex-col items-center justify-center text-center p-6 backdrop-blur-sm">
            <h2 class="text-4xl text-white font-bold mb-4">PAUSED</h2>
            <p class="text-gray-400 mb-8 font-sans">Game is paused</p>
            <button onclick="togglePause()" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg transform transition active:scale-95">
                RESUME
            </button>
        </div>
    </div>

    <script>
        function toggleFS() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    const el = document.getElementById('game-wrapper');
                    const r = el.getBoundingClientRect();
                    const s = Math.min(window.innerWidth / r.width, window.innerHeight / r.height) * 0.88;
                    el.style.transform = `scale(${s})`;
                    el.style.transformOrigin = 'center center';
                }).catch(()=>{});
            } else { document.exitFullscreen(); }
        }
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) { const el = document.getElementById('game-wrapper'); el.style.transform = ''; }
        });

        let gamePaused = false;
        function togglePause() {
            if (!running && !gamePaused) return;
            gamePaused = !gamePaused;
            document.getElementById('pause-screen').classList.toggle('hidden', !gamePaused);
            if (gamePaused) { running = false; cancelAnimationFrame(animFrame); Object.keys(keys).forEach(k => keys[k] = false); }
            else { running = true; gameLoop(); }
        }

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        const keys = {};
        let ship, bullets, enemies, asteroids, particles, stars;
        let score, wave, spawnTimer, waveTimer, running, animFrame;
        let lives, invincible, invincibleTimer;
        const SHIP_W = 24, SHIP_H = 30;
        const BULLET_SPEED = 7;
        const ENEMY_SPEED_BASE = 1.5;

        function init() {
            ship = {x: W/2 - SHIP_W/2, y: H - 60, w: SHIP_W, h: SHIP_H};
            bullets = [];
            enemies = [];
            asteroids = [];
            particles = [];
            score = 0;
            wave = 1;
            lives = 3;
            invincible = false;
            invincibleTimer = 0;
            spawnTimer = 0;
            waveTimer = 0;
            // Stars background
            stars = Array.from({length: 80}, () => ({
                x: Math.random() * W,
                y: Math.random() * H,
                s: Math.random() * 1.5 + 0.5,
                speed: Math.random() * 0.5 + 0.3
            }));
            document.getElementById('score').textContent = '0';
            document.getElementById('wave').textContent = '1';
        }

        function spawnEnemy() {
            const type = Math.random() < 0.3 ? 'fast' : 'normal';
            enemies.push({
                x: Math.random() * (W - 20) + 10,
                y: -20,
                w: type === 'fast' ? 16 : 22,
                h: type === 'fast' ? 16 : 22,
                speed: type === 'fast' ? ENEMY_SPEED_BASE + wave * 0.3 + 1 : ENEMY_SPEED_BASE + wave * 0.2,
                type,
                hp: type === 'fast' ? 1 : 2,
                shootTimer: Math.random() * 60 + 30
            });
        }

        function spawnAsteroid() {
            const size = Math.random() * 15 + 10;
            asteroids.push({
                x: Math.random() * (W - size),
                y: -size,
                r: size,
                speed: Math.random() * 1.5 + 0.8,
                rotation: 0,
                rotSpeed: (Math.random() - 0.5) * 0.05
            });
        }

        function addParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 20 + Math.random() * 20,
                    color,
                    r: Math.random() * 3 + 1
                });
            }
        }

        let shootCooldown = 0;

        function update() {
            // Ship movement
            const speed = 5;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) ship.x -= speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) ship.x += speed;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) ship.y -= speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) ship.y += speed;
            ship.x = Math.max(0, Math.min(W - ship.w, ship.x));
            ship.y = Math.max(0, Math.min(H - ship.h, ship.y));

            // Shooting
            shootCooldown--;
            if (keys[' '] && shootCooldown <= 0) {
                bullets.push({x: ship.x + ship.w/2 - 2, y: ship.y - 5, w: 4, h: 10, friendly: true});
                shootCooldown = 10;
            }

            // Move bullets
            bullets.forEach(b => { b.y += b.friendly ? -BULLET_SPEED : 4; });
            bullets = bullets.filter(b => b.y > -20 && b.y < H + 20);

            // Stars
            stars.forEach(s => {
                s.y += s.speed;
                if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
            });

            // Spawn enemies
            spawnTimer++;
            const spawnRate = Math.max(30, 80 - wave * 5);
            if (spawnTimer >= spawnRate) {
                spawnTimer = 0;
                spawnEnemy();
                if (Math.random() < 0.3) spawnAsteroid();
            }

            // Wave advancement
            waveTimer++;
            if (waveTimer >= 600) { // ~10 sec per wave
                waveTimer = 0;
                wave++;
                document.getElementById('wave').textContent = wave;
            }

            // Move enemies
            enemies.forEach(e => {
                e.y += e.speed;
                // Enemy shoots
                e.shootTimer--;
                if (e.shootTimer <= 0 && e.type === 'normal') {
                    bullets.push({x: e.x + e.w/2 - 2, y: e.y + e.h, w: 4, h: 8, friendly: false});
                    e.shootTimer = 60 + Math.random() * 40;
                }
            });
            enemies = enemies.filter(e => e.y < H + 30);

            // Move asteroids
            asteroids.forEach(a => {
                a.y += a.speed;
                a.rotation += a.rotSpeed;
            });
            asteroids = asteroids.filter(a => a.y < H + 40);

            // Particles
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
            });
            particles = particles.filter(p => p.life > 0);

            // Invincibility
            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) invincible = false;
            }

            // Bullet-enemy collision
            bullets.forEach(b => {
                if (!b.friendly) return;
                enemies.forEach((e, ei) => {
                    if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
                        e.hp--;
                        b.y = -999; // remove bullet
                        if (e.hp <= 0) {
                            score += e.type === 'fast' ? 20 : 30;
                            addParticles(e.x + e.w/2, e.y + e.h/2, e.type === 'fast' ? '#f97316' : '#ef4444', 8);
                            enemies.splice(ei, 1);
                        }
                    }
                });
                // Bullet-asteroid
                asteroids.forEach((a, ai) => {
                    const dx = (b.x + b.w/2) - a.x;
                    const dy = (b.y + b.h/2) - a.y;
                    if (Math.sqrt(dx*dx + dy*dy) < a.r) {
                        b.y = -999;
                        score += 10;
                        addParticles(a.x, a.y, '#94a3b8', 6);
                        asteroids.splice(ai, 1);
                    }
                });
            });

            document.getElementById('score').textContent = score;

            if (invincible) return;

            // Ship-enemy collision
            enemies.forEach((e, ei) => {
                if (ship.x < e.x + e.w && ship.x + ship.w > e.x && ship.y < e.y + e.h && ship.y + ship.h > e.y) {
                    loseLife();
                    enemies.splice(ei, 1);
                }
            });

            // Ship-asteroid collision
            asteroids.forEach((a, ai) => {
                const dx = (ship.x + ship.w/2) - a.x;
                const dy = (ship.y + ship.h/2) - a.y;
                if (Math.sqrt(dx*dx + dy*dy) < a.r + 10) {
                    loseLife();
                    asteroids.splice(ai, 1);
                }
            });

            // Ship-enemy bullet collision
            bullets.forEach((b, bi) => {
                if (b.friendly) return;
                if (b.x < ship.x + ship.w && b.x + b.w > ship.x && b.y < ship.y + ship.h && b.y + b.h > ship.y) {
                    loseLife();
                    bullets.splice(bi, 1);
                }
            });
        }

        function loseLife() {
            lives--;
            addParticles(ship.x + ship.w/2, ship.y + ship.h/2, '#8b5cf6', 12);
            invincible = true;
            invincibleTimer = 90;
            if (lives <= 0) {
                running = false;
                cancelAnimationFrame(animFrame);
                document.getElementById('final-score').textContent = score;
                document.getElementById('game-over').classList.remove('hidden');
            }
        }

        function draw() {
            // Space background with gradient
            const bg = ctx.createLinearGradient(0, 0, 0, H);
            bg.addColorStop(0, '#030712'); bg.addColorStop(0.5, '#0a0f1e'); bg.addColorStop(1, '#030712');
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, W, H);

            // Stars with twinkle
            stars.forEach(s => {
                const twinkle = 0.3 + Math.sin(Date.now() / 500 + s.x * 10) * 0.2;
                ctx.fillStyle = `rgba(255,255,255,${Math.min(1, s.s / 2 + twinkle)})`;
                ctx.beginPath(); ctx.arc(s.x, s.y, s.s * 0.6, 0, Math.PI * 2); ctx.fill();
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Ship
            if (!invincible || Math.floor(Date.now() / 80) % 2) {
                const cx = ship.x + ship.w/2, sy = ship.y;
                // Ship glow
                const sg = ctx.createRadialGradient(cx, sy + ship.h/2, 0, cx, sy + ship.h/2, ship.w);
                sg.addColorStop(0, 'rgba(139,92,246,0.15)'); sg.addColorStop(1, 'transparent');
                ctx.fillStyle = sg;
                ctx.fillRect(cx - ship.w, sy - 5, ship.w*2, ship.h + 10);

                // Body with gradient
                const shipGrad = ctx.createLinearGradient(cx - ship.w/2, sy, cx + ship.w/2, sy + ship.h);
                shipGrad.addColorStop(0, '#a78bfa'); shipGrad.addColorStop(1, '#7c3aed');
                ctx.fillStyle = shipGrad;
                ctx.beginPath();
                ctx.moveTo(cx, sy);
                ctx.lineTo(cx - ship.w/2, sy + ship.h);
                ctx.lineTo(cx - ship.w/4, sy + ship.h * 0.7);
                ctx.lineTo(cx + ship.w/4, sy + ship.h * 0.7);
                ctx.lineTo(cx + ship.w/2, sy + ship.h);
                ctx.closePath();
                ctx.fill();
                // Wing details
                ctx.strokeStyle = 'rgba(196,181,253,0.4)'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx, sy+5); ctx.lineTo(cx-ship.w/3, sy+ship.h-4); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, sy+5); ctx.lineTo(cx+ship.w/3, sy+ship.h-4); ctx.stroke();
                // Cockpit
                const cockpitGrad = ctx.createRadialGradient(cx, sy+12, 0, cx, sy+12, 5);
                cockpitGrad.addColorStop(0, '#e0d5ff'); cockpitGrad.addColorStop(1, '#c4b5fd');
                ctx.fillStyle = cockpitGrad;
                ctx.beginPath(); ctx.arc(cx, sy + 12, 4, 0, Math.PI * 2); ctx.fill();
                // Flame with multiple layers
                const flicker = Math.random() * 5;
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath(); ctx.moveTo(cx-5, sy+ship.h); ctx.lineTo(cx, sy+ship.h+10+flicker); ctx.lineTo(cx+5, sy+ship.h); ctx.fill();
                ctx.fillStyle = '#f97316';
                ctx.beginPath(); ctx.moveTo(cx-3, sy+ship.h); ctx.lineTo(cx, sy+ship.h+6+flicker*0.7); ctx.lineTo(cx+3, sy+ship.h); ctx.fill();
                ctx.fillStyle = '#fef3c7';
                ctx.beginPath(); ctx.moveTo(cx-1.5, sy+ship.h); ctx.lineTo(cx, sy+ship.h+3+flicker*0.4); ctx.lineTo(cx+1.5, sy+ship.h); ctx.fill();
            }

            // Lives indicator
            for (let i = 0; i < lives; i++) {
                ctx.fillStyle = '#8b5cf6';
                ctx.beginPath();
                ctx.moveTo(15 + i * 20, H - 15);
                ctx.lineTo(10 + i * 20, H - 5);
                ctx.lineTo(20 + i * 20, H - 5);
                ctx.fill();
            }

            // Enemies with improved look
            enemies.forEach(e => {
                if (e.type === 'fast') {
                    // Fast enemy with glow
                    ctx.fillStyle = 'rgba(249,115,22,0.15)';
                    ctx.beginPath(); ctx.arc(e.x+e.w/2, e.y+e.h/2, e.w, 0, Math.PI*2); ctx.fill();
                    const eGrad = ctx.createLinearGradient(e.x, e.y, e.x+e.w, e.y+e.h);
                    eGrad.addColorStop(0, '#fb923c'); eGrad.addColorStop(1, '#ea580c');
                    ctx.fillStyle = eGrad;
                    ctx.beginPath();
                    ctx.moveTo(e.x + e.w/2, e.y + e.h);
                    ctx.lineTo(e.x, e.y);
                    ctx.lineTo(e.x + e.w, e.y);
                    ctx.fill();
                } else {
                    // Normal enemy with detail
                    ctx.fillStyle = 'rgba(239,68,68,0.1)';
                    ctx.beginPath(); ctx.arc(e.x+e.w/2, e.y+e.h/2, e.w, 0, Math.PI*2); ctx.fill();
                    const eGrad = ctx.createLinearGradient(e.x, e.y, e.x, e.y+e.h);
                    eGrad.addColorStop(0, '#f87171'); eGrad.addColorStop(1, '#dc2626');
                    ctx.fillStyle = eGrad;
                    ctx.beginPath(); ctx.roundRect(e.x, e.y, e.w, e.h, 4); ctx.fill();
                    // Window
                    ctx.fillStyle = '#fca5a5';
                    ctx.beginPath(); ctx.arc(e.x + e.w/2, e.y + e.h/2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.beginPath(); ctx.arc(e.x + e.w/2 - 1, e.y + e.h/2 - 1, 1.5, 0, Math.PI * 2); ctx.fill();
                }
            });

            // Asteroids with craters
            asteroids.forEach(a => {
                ctx.save();
                ctx.translate(a.x, a.y);
                ctx.rotate(a.rotation);
                // Asteroid glow
                const aGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r*1.3);
                aGlow.addColorStop(0, 'rgba(100,116,139,0.1)'); aGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = aGlow;
                ctx.beginPath(); ctx.arc(0, 0, a.r*1.3, 0, Math.PI*2); ctx.fill();
                // Main body
                const aGrad = ctx.createRadialGradient(-a.r/4, -a.r/4, 0, 0, 0, a.r);
                aGrad.addColorStop(0, '#94a3b8'); aGrad.addColorStop(1, '#475569');
                ctx.fillStyle = aGrad;
                ctx.beginPath(); ctx.arc(0, 0, a.r, 0, Math.PI * 2); ctx.fill();
                // Craters
                ctx.fillStyle = '#374151';
                ctx.beginPath(); ctx.arc(-a.r/3, -a.r/4, a.r/4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(a.r/4, a.r/5, a.r/5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

            // Bullets with trails
            bullets.forEach(b => {
                if (b.friendly) {
                    // Trail
                    const bGrad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h + 6);
                    bGrad.addColorStop(0, '#a78bfa'); bGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = bGrad;
                    ctx.fillRect(b.x - 1, b.y, b.w + 2, b.h + 8);
                    ctx.fillStyle = '#c4b5fd';
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                } else {
                    ctx.fillStyle = '#fca5a5';
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                    ctx.fillStyle = 'rgba(252,165,165,0.3)';
                    ctx.fillRect(b.x - 1, b.y - 2, b.w + 2, b.h + 4);
                }
            });
        }

        function gameLoop() {
            if (!running) return;
            update();
            draw();
            animFrame = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            init();
            running = true;
            gameLoop();
        }

        function resetGame() {
            document.getElementById('game-over').classList.add('hidden');
            init();
            running = true;
            gameLoop();
        }

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { togglePause(); e.preventDefault(); return; }
            if (gamePaused) return;
            keys[e.key] = true;
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        // Mobile: touch to move ship toward finger, tap to shoot
        let mobileShoot = null;
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const tx = (e.touches[0].clientX - rect.left) * (W / rect.width);
            const ty = (e.touches[0].clientY - rect.top) * (H / rect.height);
            ship.x = tx - ship.w/2;
            ship.y = ty - ship.h/2;
            keys[' '] = true;
            mobileShoot = setInterval(() => { keys[' '] = true; }, 150);
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const tx = (e.touches[0].clientX - rect.left) * (W / rect.width);
            const ty = (e.touches[0].clientY - rect.top) * (H / rect.height);
            ship.x = tx - ship.w/2;
            ship.y = ty - ship.h/2;
        }, {passive: false});
        canvas.addEventListener('touchend', () => {
            keys[' '] = false;
            if (mobileShoot) { clearInterval(mobileShoot); mobileShoot = null; }
        });

        init();
    </script>
</body>
</html>
